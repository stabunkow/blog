---
title: 数学建模-数模基础
date: 2021-05-14 20:01:02
mathjax: true
tag: [数学建模]
---



# 假设检验

在 *相关性分析*、*回归分析* 等问题中，需要对数据的分布做出合理假设，认为其符合某种分布，这样分析才有意义。

在原假设成立的情况下，数据需要满足 **某一分布**，p 值为当原假设为真时，比所得到的样本观察结果更极端的结果出现的概率。原假设 $H_0$ 成立时的最低显著性水平为 $\alpha$ ， 若 p 值大于 $\alpha$ ，接受原假设，$1 - \alpha$  即为置信水平。

## 步骤

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210422141019850.png)

## 均值检验

在已知样本服从正态分布的情况下，比较两个平均数的差异是否显著，从而承认或拒绝原假设。

![](https://img-blog.csdn.net/20180624110938247?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5ndWl5dXl1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

*Z 检验* 的核心是总体服从正态分布，且该正态分布的均值未知，需要我们检验，但 **方差** 已知。

然而，在 **现实问题** 中，总体的方差也往往是未知的，如果总体方差未知，可以通过引入样本方差，来进行 *t 检验*。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210422141259974.png)

### 例题

为了比较两种产品、两种仪器、两种方法等的 **差异**，我们常在 **相同** 的条件下做对比试验，得到一批成对的观察值，然后分析观察数据作出推断，这种方法常称为逐对比较法。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210422141941592.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210422142902242.png)

## 分布检验

不能知道总体服从什么类型的分布，这时就需要根据样本来检验关于分布的假设，使用 *卡方拟合检验法*，它可以用来检验总体是否具有某一个指定的分布或属于某一个分布族。

# 描述统计

## Excel

F4 技巧，函数，数据透视表。

饼图、柱状图、条形图、直方图、折线图、散点图、箱线图的绘画使用。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421200940453.png)

## Matlab

```matlab
MIN = min(Test); % 每一列的最小值
MAX = max(Test); % 每一列的最大值
MEAN = mean(Test); % 每一列的均值
MEDIAN = median(Test); %每一列的中位数
SKEWNESS = skewness(Test); %每一列的偏度
KURTOSIS = kurtosis(Test);  %每一列的峰度
STD = std(Test);  % 每一列的标准差
RESULT = [MIN;MAX;MEAN;MEDIAN;SKEWNESS;KURTOSIS;STD]
```

## SPSS

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421201009807.png)

# Matlab 使用

## 实时脚本运行

可以美化公式。

## 三维绘图

```matlab
X = [1 2 4];
Y = [3 5];
Z = [4 8 10; 5 9 13] % n * m
mesh(X, Y, Z) % 也可以一一对应
xlabel('x轴')  
ylabel('y轴')  
zlabel('z轴')

mesh(Z) % 单纯绘图 X 1:3 Y 1:2
hidden off %% 取消遮挡

%% 以 mesh 低密度形成曲线
n = 11;
tem = linspace(0, 5, n); % 0-5 等距分隔成 n 份
x = repmat(tem, n, 1);
y = repmat(tem, n, 1);
z = x .^ 2 - y .^ 2;
mesh(x, y, z)
axis vis3d

[x, y] = meshgrid(-5:0.5:5); % 限制区域
tem = sqrt(x .^ 2 + y .^ 2 + 1e-12); % eps 也可以，防止 0/0 = NaN
z = sin(tem) ./ tem;
mesh(x, y, z)
axis vis3d

% meshc 同时绘制等高线
% meshz 加底柱
% surf 绘制面
[x, y] = meshgrid(linespace(0, 5, 11));
z = x .^ 2 - y .^ 2;
subplot(1, 2, 1)
mesh(x, y, z)
title('mesh')
axis vis3d

subplot(1, 2, 1)
surf(x, y, z)
title('surf')
axis vis3d
% surfl 加灯光
% shading flat/interp 光滑模式

[x, y] = meshgrid(-3:0.1:3);
peaks
maxz = max(max(z));
minz = min(min(z));
levels = linspace(minz, maxz, 5); % levels 为数值也可以
contour(x, y, z, levels, '--', 'LineWidth', 2, 'ShowText', 'on')
% contourf contour3

%% plot3 三位空间折线图
t = linespace(0, 4 * pi, 100);
x = sin(t) + 1;
y = cos(t);
z = t;
plot3(x, y, z);

% 符号函数
syms u v
r = 2 + sin(7 .* u + 5 .* v);
x = r .* cos(u) .* sin(v);
y = r .* sin(u) .* sin(v);
z = r .* cos(v);
fmesh(x, y, z, [0 2 * pi 0 pi])

% 隐函数绘制
f = @(x, y, z) x .^ 2 + y .^ 2 - z .^ 2; % == 0
fimplicit(f);
```

## 符号运算

不定积分、定积分求解，方程组求解。

 ```matlab
% 符号表达式可以化解、因式分解
y = m ^ 2 - n ^ 2;
simplify(y)
factor(y)
expand(y) % 多项式展开
collect(y) % 多项式合并
[z1, z2] = numden(sym(2.5)) % 计算分子和分母
mupad % 符号运算工具箱

syms x
y = x ^ 4 - 5 * x ^ 2 + 6
diff(y) % 求一阶导
diff(y, 2) % 求二阶导
% 注意对矩阵 diff 是求差分

y = cos(x) * tan(x)
dy = diff(y, 10)
simplify(dy)

syms x1 x2 x3
y1 = x1^5*x2+x2*x3-x1^2*x3
py1 = diff(y1,x1,1) % 对x1求一阶偏导
py2 = diff(y1,x1,x2) % 先对x1求偏导，再对x2求偏导

% 不定积分 不会加上常数和绝对值
syms x
y = x ^ 2
int(y, x)
syms x
y = 1/x
int(y, x)

% 定积分 不是所有函数都能推出积分
syms x
y = sin(x)
int(y, x, 0, pi / 2)
syms x a b
y = exp(x)
int(y, x, a, b)

y = 1 / exp(x) * log(x+2*x^2+sin(x)) % 无法求出积分
int(y,x,0,4)
% 我们可以计算数值积分：数值积分可用于求定积分的近似值
syms x 
y = @(x) 1 ./ exp(x) .* log(x+2.*x.^2+sin(x))  % 注意，写成函数句柄时，要用点乘或者点除
integral(y,0,4)

%% 例题1: 求解单变量方程
syms x
answ = solve(sin(x) == 1, x)
eqn = (sin(x) == 1)
% 因为三角函数是周期函数，如果要得到所有的解，则需要加上条件
[answ, params, condions] = solve(eqn, x, 'ReturnConditions', true)

%% 例题2: 多变量方程求解
syms a b c x
eqn = (a*x^2 + b*x + c == 0);
answ1 = solve(eqn, x)  % 将x视为未知数求解 
answ2 = solve(eqn, a) % 将a视为未知数求解

%% 例题3：方程组求解
syms u v a
eqn = [2*u + v == a, u - v == 1];
answ = solve(eqn, [u, v])
answ.u
answ.v
[answ_u, answ_v] = solve(eqn, [u, v])

%% solve 可能会警告
syms x
eqn = (sin(x) == x^2 - 1);
solve(eqn, x)  % 警告
% 画图看看 
fplot(sin(x), [-2 2])  % fplot函数可绘制表达式的图形
hold on
fplot(x^2 - 1, [-2 2]) 

%% vpasolve函数求解，可以指定区间
syms x
eqn = sin(x) == x^2 - 1;
vpasolve(eqn, x, [0 2])
vpasolve(eqn, x, [-1 0])
vpasolve(eqn, x, [-10 10])
vpasolve(eqn, x, 'random', true) 
vpasolve(eqn, x, -5)   % 给定搜索的起始点

syms x y
eqn = [x^2 - 2*x - 3*x*y == 10, y^4 == exp(-2*x/3*y)]
fimplicit(x^2 - 2*x - 3*x*y == 10, [-10 10],'r')
hold on
fimplicit(y^4 == exp(-2*x/3*y), [-10 10],'b')
[answ_x, answ_y] = vpasolve(eqn, [x, y],[-4 -1;1 5])
hold on
% 符号变量变回数值变量
plot(double(answ_x), double(answ_y), 'ko', 'MarkerSize', 10) 

% 默认工具箱求解
function F = my_fun(x)
    F(1) = exp(-exp(-(x(1)+x(2)))) - x(2)*(1+x(1)^2);
    F(2) = x(1)*cos(x(2)) + x(2)*sin(x(1)) - 0.5;
end
x0 = [0,0];  % 初始值
result_x = fsolve(@my_fun,x0)

% 效果等同于
syms x1 x2
eqn =  [exp(-exp(-(x1+x2))) - x2*(1+x1^2) == 0, x1*cos(x2) + x2*sin(x1) - 0.5 == 0]
[answ_x1, answ_x2] = vpasolve(eqn, [x1, x2], [0 0])
 ```

