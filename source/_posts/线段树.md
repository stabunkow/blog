---
title: 线段树
date: 2021-03-09 10:25:41
mathjax: true
tag: [OJ, haizeiOJ, 二叉树, 线段树]
---

# 线段树

用来表示集合关系中的某个属性，拥有相同父结点的同属一个集合，子结点是父节点根据不同关系分出来的子集。具有对集合进行单点修改，区间查询，区间修改这几个功能，采用分治的思想来对区间进行划分，直到区间只剩一个结点，叶子结点代表原集合单个位置的值。采用完全二叉树的存储结构，需要更大的存储空间，常为 4n （n 为集合内元素个数）。

代码实现上，使用静态数组实现逻辑树，通过计算得到边关系。修改操作后，需要把修改结果向上传递通知父结点更新，区间修改时可以用 **懒标记** ，先不把修改操作结果下放到子结点，出现查询后才去先更新子结点。

**区间和线段树示意**（区间修改使用了懒标记）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210122193812756.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210122193903361.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210122194058282.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210122194542153.png)

## 区间最大值

使用该例题说明：[线段树模板(一)](http://oj.haizeix.com/problem/222)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309140903584.png)

**样例输入**

```
6 5
6 9 4 3 2 1
2 2 5
1 2 3
2 1 6
1 5 12
2 1 6
```

**样例输出**

```
9
6
12
```

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAX_N 10000
#define L(ind) (ind << 1)
#define R(ind) (ind << 1 | 1)

// 线段树模板
struct {
    int max_num;
} tree[MAX_N << 2];
int arr[MAX_N + 5];

// 向上更新
void update(int ind) {
    tree[ind].max_num = max(tree[L(ind)].max_num, tree[R(ind)].max_num);
    return ;
}

// ind 为线段树节点，传入 l r 帮助建树
void build_tree(int ind, int l, int r) {
    if (l == r) {
        tree[ind].max_num = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build_tree(L(ind), l, mid);
    build_tree(R(ind), mid + 1, r);
    update(ind);
    return ;
}

// ind 为线段树节点，传入 l r 帮助修改
// 单点修改
void modify(int ind, int l, int r, int k, int val) {
    if (l == r) {
        tree[ind].max_num = val;
        return ;
    }
    int mid = (l + r) >> 1;
    if (k <= mid) {
        modify(L(ind), l, mid, k, val);
    } else {
        modify(R(ind), mid + 1, r, k, val);
    }
    update(ind); // #!
    return ;
}

// ind 为线段树节点，传入 l r 帮助查询
int query(int ind, int l, int r, int x, int y) {
    if (x <= l && r <= y) {
        return tree[ind].max_num;
    }
    // 可以画图理解
    int ans = INT_MIN;
    int mid = (l + r) >> 1;
    if (x <= mid) {
        ans = max(ans, query(L(ind), l, mid, x, y));
    }
    if (mid < y) { // #!
        ans = max(ans, query(R(ind), mid + 1, r, x, y));
    }
    return ans;
}

int main() {
    int n, m, a, b, c;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", arr + i);
    }
    build_tree(1, 1, n);

    while (m--) {
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1:
                modify(1, 1, n, b, c);
                break;
            case 2:
                if (b > c) {
                    printf("-2147483648\n");
                } else {
                    printf("%d\n", query(1, 1, n, b, c));
                }
                break;
        }
    }

    return 0;
}
```

## 区间和值

使用该例题说明：[线段树模板(二)](http://oj.haizeix.com/problem/223)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309141636035.png)

**样例输入**

```
6 5
6 9 4 3 2 1
2 2 5
1 2 3 5
2 1 6
1 5 12 3
2 1 6
```

**样例输出**

```
18
35
41
```

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAX_N 10000
#define L(ind) (ind << 1)
#define R(ind) (ind << 1 | 1)

// 线段树模板（含懒标记）
struct {
    long long sum, tag;
} tree[MAX_N << 2];
long long arr[MAX_N + 5];

void update(long long ind) {
    tree[ind].sum = tree[L(ind)].sum + tree[R(ind)].sum;
    return ;
}

// 懒标记下沉
void down(long long ind, long long l, long long r) {
    if (tree[ind].tag) {
        long long val = tree[ind].tag;
        long long mid = (l + r) >> 1;
        tree[L(ind)].sum += val * (mid - l + 1); // 左开右闭
        tree[L(ind)].tag += val;
        tree[R(ind)].sum += val * (r - mid); 
        tree[R(ind)].tag += val;
        tree[ind].tag = 0;
    }
    return ;
}

void build_tree(long long ind, long long l, long long r) {
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }

    long long mid = (l + r) >> 1;
    build_tree(L(ind), l, mid);
    build_tree(R(ind), mid + 1, r);
    update(ind);
    return ;
}

void modify(long long ind, long long l, long long r, long long x, long long y, long long val) {
    if (x <= l && r <= y) {
        // 限制下沉，其后查询可更新
        tree[ind].sum += val * (r - l + 1);
        tree[ind].tag += val;
        return ;
    }

    // 先下沉更新
    down(ind, l, r);
    long long mid = (l + r) >> 1;
    if (x <= mid) {
        modify(L(ind), l, mid, x, y, val);
    }
    if (mid < y) {
        modify(R(ind), mid + 1, r, x, y, val);
    }
    update(ind);
    return ;
}

long long query(long long ind, long long l, long long r, long long x, long long y) {
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }

    down(ind, l, r);
    long long mid = (l + r) >> 1;
    long long ans = 0;
    if (x <= mid) {
        ans += query(L(ind), l, mid, x, y);
    }
    if (mid < y) {
        ans += query(R(ind), mid + 1, r, x, y);
    }
    
    return ans;
}

int main() {
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (long long i = 1; i <= n; ++i) {
        scanf("%lld", arr + i);
    }
    build_tree(1, 1, n);

    long long a, b, c, d;
    for (long long i = 0; i < m; ++i) {
        scanf("%lld%lld%lld", &a, &b, &c);
        switch (a) {
            case 1:
                scanf("%lld", &d);
                modify(1, 1, n, b, c, d);
                break;
            case 2:
                if (b > c) {
                    printf("0\n");
                } else {
                    printf("%lld\n", query(1, 1, n, b, c));
                }
                break;
        }
    }

    return 0;
}
```

