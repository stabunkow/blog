---
title: 数学建模-插值与拟合
date: 2021-05-14 20:03:32
mathjax: true
tag: [数学建模]
---



# 插值算法

现有数据不够，不足以进行分析，需要补充一些靠谱的值。

插值算法经过 **所有已知点**，包含插值区间 $[a, b]$

插值算法存在 代数多项式、分段多项式、三角多项式。

## 多项式插值法

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421184001641.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421184125977.png)

## 拉格朗日插值法

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421184234418.png)

## 龙格现象

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421184407055.png)

## 分段插值

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421184649189.png)

可进行分段线性插值、分段二次插值（在$x_{i-1}, x_i, x_{i+1}$上）等。

## 牛顿插值

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421185036121.png)

牛顿插值法的计算过程具有继承性，有新项时，可以在前 $n$ 项的添加新的项即可。

## Hermite 插值

不但要求在节点上的函数值相等，而且还要求对应的导数值也相等,甚至要求高阶导数也相等，保持函数光滑，密和程度更好。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421185619386.png)

实际使用时，直接使用高次多项式 Hermite 插值会有龙格现象问题，所以往往使用分段三次进行 Hermite 插值。

## 三次样条插值

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421190127791.png)

相比 Hermite 插值，三次样条插值更加平滑。

## Matlab 使用

```matlab
x = -pi:pi; % 默认间隔1
y = sin(x);
new_x = -pi:0.1:pi;
p1 = pchip(x, y, new_x); % hermite 三次插值
p2 = spline(x, y, new_x); % 三次样条插值
% p2 = interpn (x, y, new_x, 'spline');
% 等价使用，默认 linear spline 最为精准
figure(1)
plot(x, y, 'o', new_x, p1, 'r-', new_x, p2, 'b-')
legend('样本点', '三次 hermite 插值', '三次样条插值', 'Location', 'SouthEast')
```

# 拟合算法

所给定的曲线不一定经过所有给定点，只要求曲线在某种准则下跟已有的数据点最为接近，误差损失最小，拟合最好。

## 拟合评价

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421192328510.png)

拟合的初衷是简单，太复杂过拟合也不好。

只有线性函数才能用于拟合优度，**复杂函数**（复合函数）不行，只看 SSE 即可。 

线性函数：对参数 arg 为线性，例如： $y=a+b x^2$，线性于参数（参数没有高次，不能有乘或除或参数的复合）

$y=e^{\beta_1+\beta_2x}$ 是线性函数，$y=a\sin(b+cx)$ 不是。

## 最小二乘法

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421191608952.png)

### Matlab 使用

```matlab
load data1
plot(x, y, 'o')
xlabel('x的值')
ylabel('y的值')
n = size(x, 1);
k = (n * sum(x .* y) - sum(x) * sum(y)) / (n * sum(x .* x) - sum(x) * sum(x));
b = (sum(x .* x) * sum(y) - sum(x) * sum(x .* y)) / (n * sum(x .* x) - sum(x) * sum(x));
hold on
grid on
f = @(x) k * x + b;
fplot(f, [2.5, 7]) % 指定区间绘图
legend('样本数据', '拟合函数', 'location', 'SouthEast')

y_hat = k * x +b; % y 的拟合值
SSR = sum((y_hat - mean(y)) .^ 2)  % 回归平方和
SST = sum((y - mean(y)).^2) % 总体平方和
R_2 = SSR / SST
```

## 其他拟合方法

当数据量过大时，最小二乘法可能满足不了计算（例如内存不足），可能有其他以迭代为基础的拟合方法。

如 *梯度下降法*、*随机梯度下降法*、*共轭梯度下降法*等。

拟合时，需要选择变量起始迭代点，还有迭代步数。

```matlab
year = 1790:10:2000;
population = [3.9 5.3 ...];
plot(year,population,'o')
cftool  % 拟合工具箱
% (1) X data 选择 year
% (2) Y data 选择 population
% (3) 拟合方式选择：Custom Equation (自定义方程)
% (4) 修改下方的方框为：x = f(t) = xm/(1+(xm/3.9-1)*exp(-r*(t-1790)))
% (5) 左边的result一栏最上面显示：Fit computation did not converge:即没有找到收敛解
% (6) 点击Fit Options，修改非线性最小二乘估计法拟合的初始值(StartPoint), r修改为0.02，xm修改为500 
% (7) 依次点击拟合工具箱的菜单栏最左边的文件—Generate Code
[fitresult, gof] = createFit(year, population)
t = 2001:2030;
xm = 342.4; 
r = 0.02735;
predictions = xm ./ (1 + (xm ./ 3.9 - 1) .* exp(- r .* (t-1790)));  % 计算预测值
figure(2)
plot(year, population, 'o', t, predictions, '.')  % 绘制预测结果图
```

