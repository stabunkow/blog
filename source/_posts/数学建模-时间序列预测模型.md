---
title: 数学建模-时间序列预测模型
date: 2021-05-14 20:01:03
mathjax: true
tag: [数学建模]
---



# 时间序列分析

时间序列也称动态序列，是指将某种现象的指标数值按照时间顺序排列而成的数值序列。

时间序列分析大致可分成三大部分，分别是描述过去、分析规律和预测未来。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427153139000.png)

时间序列由两个组成要素构成：

1. 第一个要素是时间要素：年、季度、月、周、日、小时、分钟、秒
2. 第二个要素是数值要素

时间序列可以分为时期时间序列和时点时间序列：

- **时期序列** 中，数值要素反映现象在一定时期内发展的结果
- **时点序列** 中，数值要素反映现象在一定时点上的瞬间水平

时期序列可加，时点序列不可加。

# 时间序列分解

因为时间序列是某个指标数值长期变化的数值表现，所以时间序列数值变化背后必然蕴含着数值变换的规律性，这些规律性就是时间序列分析的切入点。

一般情况下，时间序列的 **数值变化规律** 有以下四种：（数值变化规律分开观察）

- 长期变动趋势
- 季节变动规律
- 周期变动规律
- 不规则变动（随机扰动项）

一个时间序列往往是以上四类变化形式的 **叠加**。

长期趋势 **T** 指的是统计指标在相当长的一段时间内，受到 **长期趋势影响因素** 的影响，表现出 **持续上升** 或 **持续下降** 的趋势，通常用字母 T 表示。例如，随着国家经济的发展，人均收入将逐渐提升；随着医学水平的提高，新生儿死亡率在不断下降。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427153633160.png)

季节趋势 **S** 是指由于 **季节的转变** 使得指标数值发生 **周期性变动** 。这里的季节是 **广义** 的，一般以月、季、周为时间单位，不能以 **年** 作单位。例如雪糕和棉衣的销量都会随着季节气温的变化而周期变化；每年的长假（五一、十一、春节）都会引起出行人数的大量增加。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427153759975.png)

循环变动 **C** 与季节变动的周期不同，循环变动通常以 **若干年** 为周期，在曲线图上表现为 **波浪式** 的周期变动。这种周期变动的特征表现为增加和减少 **交替** 出现，但是并不具 **严格规则** 的周期性连续变动。最典型的周期案例就是市场经济的商业周期和的整个国家的经济周期。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427154013293.png)

不规则变动 **I** 是由某些随机因素导致的数值变化，这些因素的作用是不可预知和没有规律性的，可以视为由于众多 **偶然** 因素对时间序列造成的影响（在回归中又被称为扰动项）。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427154055743.png)

以上四种变动就是时间序列数值变化的 **分解** 结果。

有时这些变动会同时出现在一个时间序列里面，有时也可能只出现一种或几种，这是由引起各种变动的影响因素决定的。正是由于变动组合的不确定性，时间序列的数值变化才那么千变万化。

四种变动与指标数值最终变动的关系可能是 **叠加** 关系，也可能是 **乘积** 关系。

如果四种变动之间是相互独立的关系，那么叠加模型可以表示为：$Y=T+S+C+I$

如果四种变动之间存在相互影响关系，那么应该使用乘积模型：$Y=T \times S \times C \times I$

数据具有 **年内的周期性时** 才能使用时间序列分解，例如数据包含月份数据(周期为12)、季度数据(周期为4) ，如果 **单纯** 是年份数据则不行。

在具体的时间序列图上，如果随着时间的推移，序列的季节 **波动变得越来越大** ，则反映各种变动之间的关系发生变化，建议使用乘积模型；反之，如果时间序列图的 **波动保持恒定**，则可以直接使用叠加模型；当然，如果不存在季节波动，则两种分解均可以。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427154703653.png)

## SPSS 操作

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427154826619.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427154938459.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427155014860.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427155048405.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427155251732.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427155406628.png)

# 未来指标预测

## 指数平滑模型

### Simple 模型

不含 **趋势** 和 **季节** 成分，由过去数据 **加权** 所得，只能预测 **1** 期。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427160443250.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427160653727.png)

红色是预测的线。

### 霍特 / 布朗线性趋势模型

含有 **线性趋势**、不含 **季节** 成分

该方法包含一个预测方程和两个平滑方程（一个用于水平，另一个用于趋势）。原理不细讲。

由式子不断递推所得。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427161415441.png)

### 阻尼趋势模型

霍特线性趋势模型对对未来预测值过高，特别是对于长期预测。引入了一种 **阻尼** 效应，用来缓解较高的线性趋势。（比如人口、GDP）

$\phi$ 越小，阻力越大。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427161834051.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427161925157.png)

### 简单季节性模型

不含 **趋势**，含 **稳定季节成分** 。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427162147223.png)

### 温特加法模型

含有 **线性趋势** 和 **稳定季节成分** （时间序列分解加法）。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427162434210.png)

### 温特乘法模型

含有 **线性趋势** 和 **不稳定季节成分** （时间序列分解乘法）。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427162511905.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427162622987.png)

由于是乘法，认为不稳定，蓝色的线会波动大一点。



SPSS 专家建模的一些问题，如果是预测可不用关注参数显著值，解释需要，但是有的时候已经给了最好的模型，显著值可能不佳。

## 一元时间序列分析模型

### 时间序列的平稳性

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427163900337.png)

只有 b g 是平稳的。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427164249314.png)

### 差分方程

滞后项，之前 $p$ 个数据。

将某个时间序列变量表示为该变量的 **滞后项**、 **时间 t** 和 **其他变量** 的函数，这样的一个函数方程被称为差分方程。

扰动项没有一般说明默认为 白噪声 序列。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427165117945.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427165227078.png)

### 滞后算子

是一种表达式写法，方便表示。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427165642561.png)

### AR(p) 模型

为预测，生成的模型。

包含收 **自身因素** 影响较大的现象，对受 其他因素 影响不宜使用。

需要模型 **稳定**，共有 $p$ 阶元素，由于模型（自回归模型）特性，具有 **自相关** 现象。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427170802064.png)

AR(q) 模型平稳的条件：（模长，解的长度大小）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427172028993.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427172150223.png)

### MA(q) 模型

q 阶 **移动平均**，使用扰动项，使得均值较为平稳。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427190608642.png)



![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427191007976.png)

1 阶移动平均模型可以和无穷阶的自回归模型相互转换，但是需要模型中的参数少，所以还是要移动平均过程。

#### MA(q) 平稳证明

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427191346473.png)

### ARMA(p, q) 模型

无趋势和季节性。

自回归移动平均模型，就是设法将自回归过程 AR 和移动平均过程 MA 结合起来，**共同模拟** 产生既有时间序列样本数据的那个随机过程的模型。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427191527084.png)

ARMA 模型的平稳性和自回归 AR 模型相关，MA 一定是平稳的。

一般，我们可以通过观察时序图来判断时间序列是否平稳，当然，也有相应的假设检验方法能帮助我们对数据的平稳性进行检验。

### ACF 相关系数

反映 $x_t$ 和 $x_{t-s}$ 之间的相关系数。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427192728250.png)

### PACF 偏自相关系数

用于衡量 $x_t$ 和 $x_{t-s}$ 之间剔除掉所有中间取值后的线性关系。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427193244049.png)

### ARMA 模型识别和估计

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427193402971.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427193422471.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427193520111.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427193731632.png)

通过图形识别 ARMA 模型的拖尾现象，但识别 **阶数** 较为困难，求解需要依赖于计算机。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427194029531.png)

### 模型选择

往往使用 BIC 准则。



![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427194444160.png)

原假设为残差为 0，p 值 大于 0.05 可接受。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427194827652.png)

### ARIMA 模型

差分自回归移动平均模型，通过差分，使得模型变得平稳。

![image-20210427195248970](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427195248970.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427195226853.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427195340604.png)

### SARIMA 模型

到目前为止，我们只关注非季节性数据和非季节性 ARIMA 模型。然而，ARIMA 模型也能够对广泛的季节数据进行建模。季节性ARIMA模型是通过在 ARIMA 模型中包含额外的季节性项而生成的，其形式如下：

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427195454598.png)

### ARCH 模型

自回归条件异方差模型，在现代高频金融时间序列中，数据经常出现波动性聚集的特点，但从长期来看数据是平稳的，即长期方差（无条件方差）是定值，但从短期来看方差是不稳定的，我们称这种异方差为条件异方差。传统的时间序列模型如ARMA模型识别不出来这一特征。ARCH 模型的实质是对扰动项进行建模。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428141452691.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428141718171.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428141944170.png)

### GARCH 模型

广义的 ARCH 模型。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428142348994.png)

使用 LM 检验 GARCH 效应，对 扰动项评分进行检验。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428142437533.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428142700532.png)

# 灰色预测

灰色预测是对既含有已知信息又含有不确定信息的系统进行预测，就是对在一定范围内变化的、与 **时间**有关的灰色过程进行预测。

灰色预测对原始数据进行生成处理来寻找系统变动的规律，并生成有较强 **规律性** 的数据序列，然后建立相应的 **微分方程模型**，从而预测事物未来发展趋势的状况。

GM(1,1) （第一个 1 表示微分方程是**一阶的**，后面的 1 表示只有**一个变量**）是使用原始的离散非负数据列，通过一次 **累加** 生成削弱随机性的较有规律的新的离散数据列，然后通过建立微分方程模型，得到在离散点处的解经过累减生成的原始数据的近似估计值，从而预测原始数据的后续发展。

AGO 序列累加数据列，$x^{(1)}(m)=\sum\limits^m_{i=0}{x^{(0)}(i)}$, $x^{(0)}$ 为原数据列，$z^{(1)}$ 为紧邻均值生成序列。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428164949228.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428165408638.png)

## OLS 回归原理复习

OLS 最小二乘法。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428165708350.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428165936523.png)

要求 $X^TX$ 可逆，列满秩，还可以推导到多系数的情况。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428170117415.png)

如果 $X^TX$ 不可逆，要么增加样本，要么减少系数（岭回归思想，$ X^TX+\lambda I$ 一定可逆）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428170954491.png) 

灰建模的初衷是对 **数列** 建立 **近似** 的 **微分方程模型** ，但是由于微分方程只适合连续可微函数,  而时间序列数据非连续，更谈不上可微性，因此灰色预测建模得到的是近似微分方程，称之为灰微分方程。

一阶微分方程求解知识（高数）：

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428171747866.png)

所以可得

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428171954961.png)

所以要求数据具有准指数规律。

## 准指数规律检验及评价

关注 级比 和 光滑比。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428182236623.png)

发展系数 $a$ 越小预测的越精确。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428182411169.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428183036016.png)

## GM(1,1)模型的拓展

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428183748156.png)

灰色预测使用：

1. 数据是以年份度量的非负数据（如果是月份或者季度数据一定要用上时间序列模型）
2. 数据能经过准指数规律的检验（除了前两期外，后面至少90%的期数的光滑比要低于0.5）
3. 数据的期数较短且和其他数据之间的关联性不强（小于等于10，也不能太短了，比如只有3期数据），要是数据期数较长，一般用传统的时间序列模型比较合适

## 代码

```matlab
function [result, x0_hat, relative_residuals, eta] = gm11(x0, predict_num)
	% 函数作用：使用传统的GM(1,1)模型对数据进行预测
    %     x0：要预测的原始数据
    %     predict_num： 向后预测的期数
    % 输出变量：
    %     result：预测值
    %     x0_hat：对原始数据的拟合值
    %     relative_residuals： 对模型进行评价时计算得到的相对残差
    %     eta： 对模型进行评价时计算得到的级比偏差
    n = length(x0);
    x1 = cumsum(x0);
    z1 = (x1(1:end-1) + x1(2:end)) / 2;
    y = x0(2:end);
    x = z1;
    % OLS 最小二乘法
    k = ((n - 1) * sum(x .* y) - sum(x) * sum(y)) / ((n - 1) * sum(x .* x) - sum(x) * sum(x));
    b = (sum(x .* x) * sum(y) - sum(x) * sum(x .* y)) / ((n - 1) * sum(x .* x) - sum(x) * sum(x));
    % -a就是发展系数,  b就是灰作用量
    a = -k;
    disp('现在进行GM(1,1)预测的原始数据是: ')
    disp(mat2str(x0'))
    disp(['最小二乘法拟合得到的发展系数为' num2str(-a) '，灰作用量是' num2str(b)])
    disp('***************分割线***************')
    
    % 拟合值计算
    x0_hat = zeros(n, 1);
    x0_hat(1) = x0(1);
    for m = 1:n-1
        x0_hat(m+1) = (1 - exp(a)) * (x0(1) - b/a) * exp(-a*m);
    end
    
    % 保存预测值
    result = zeros(predict_num, 1);
    for i = 1:predict_num
        result(i) = (1 - exp(a)) * (x0(1) - b/a) * exp(-a * (n+i-1)); % 带入公式直接计算
    end
    
    % 计算绝对残差和相对残差
    absolute_residuals = x0(2:end) - x0_hat(2:end);
    relative_residuals = abs(absolute_residuals) ./ x0(2:end);
    
    % 计算级比和级比偏差
    class_ratio = x0(2:end) ./ x0(1:end-1);  % 计算级比 sigma(k) = x0(k) / x0(k-1)
    eta = abs(1-(1-0.5*a)/(1+0.5*a)*(1./class_ratio));  % 计算级比偏差
end

function [result] = new_gm11(x0, predict_num)
	% 函数作用：使用新信息的GM(1,1)模型对数据进行预测
    % 输入变量
    %     x0：要预测的原始数据
    %     predict_num： 向后预测的期数
    % 输出变量
    %     result：预测值
    result = zeros(predict_num, 1);
    for i = 1:predict_num
    	% 不断使用新的预测值加入再去预测
    	result(i) = gm11(x0, 1);
    	x0 = [x0; result(i)];
    end
end

function [result] = metabolism_gm11(x0, predict_num)
    % 函数作用：使用新陈代谢的GM(1,1)模型对数据进行预测
    % 输入变量
    %     x0：要预测的原始数据
    %     predict_num： 向后预测的期数
    % 输出变量
    %     result：预测值
    result = zeros(predict_num, 1);
    for i = 1:predict_num  
        result(i) = gm11(x0, 1);  % 将预测一期的结果保存到result中
        x0 = [x0(2:end); result(i)];  % 更新x0向量，此时x0多了新的预测信息，并且删除了最开始的那个向量，队列轮转
    end
end

year = [1995:1:2004]';
x0 = [174, 179, 183, 189, 207, 234, 220.5, 256, 270, 285]';  % 原始数据序列

figure(1)
plot(year, x0, 'o-')
grid on
set(gca, 'xtick', year(1:1:end))
xlabel('年份')
ylabel('排污总量')

if sum(x0 < 0) > 0
	disp('灰色预测的时间序列中不能有负数')
	return
end

n = length(x0);
disp(['原始数据的长度为' num2str(n)])
if n <= 3
	disp('数据量太小')
    return
end

% 数据太多时提示可考虑使用其他方法（不报错）
if n > 10
    disp('数据量多，一定要考虑使用其他的方法，例如ARIMA，指数平滑等')
end

disp('------------------------------------------------------------')
disp('准指数规律检验')
x1 = cumsum(x0); % 生成 AGO 序列
rho = x0(2:end) ./ x1(1:end-1); % 计算光滑度rho(k) = x0(k) / x1(k-1)
figure(2)
plot(year(2:end), rho, 'o-', [year(2), year(end)], [0.5, 0.5], '-') 
grid on
text(year(end-1) + 0.2, 0.55, '临界线')
set(gca, 'xtick', year(2:1:end))
xlabel('年份')
ylabel('原始数据的光滑度')

disp(['指标1：光滑比小于0.5的数据占比为' num2str(100 * sum(rho< 0.5) / (n - 1)) '%'])
disp(['指标2：除去前两个时期外，光滑比小于0.5的数据占比为' num2str(100 * sum(rho(3:end) < 0.5) / (n-3)) '%'])
disp('参考标准：指标1一般要大于60%, 指标2要大于90%')
Judge = input('你认为可以通过准指数规律的检验吗？可以通过请输入1，不能请输入0：');
if Judge == 0
	return
end

if n <= 4
	disp('数据只有4期，因此我们直接将三种方法的结果求平均即可~')
	predict_num = input('请输入你要往后面预测的期数： ');
	disp(' ')
	disp('***下面是传统的GM(1,1)模型预测的详细过程***')
	[result1, x0_hat, relative_residuals, eta] = gm11(x0, predict_num
	disp(' ')
	disp('***下面是进行新信息的GM(1,1)模型预测的详细过程***')
	result2 = new_gm11(x0, predict_num);
    disp(' ')
    disp('***下面是进行新陈代谢的GM(1,1)模型预测的详细过程***')
    result3 = metabolism_gm11(x0, predict_num);
    result = (result1 + result2 + result3) / 3;
    result
else
	disp('因为原数据的期数大于4，所以我们可以将数据组分为训练组和试验组')
	if n > 7
        test_num = 3;
	else
    	test_num = 2;
    end
    train_x0 = x0(1:end-test_num);
    disp('训练数据是: ')
    disp(mat2str(train_x0'))
    test_x0 = x0(end-test_num+1:end);
    disp('试验数据是: ')
    disp(mat2str(test_x0'))
    disp('------------------------------------------------------------')
    
    disp(' ')
	disp('***下面是传统的GM(1,1)模型预测的详细过程***')
	result1 = gm11(train_x0, test_num);
	disp(' ')
    disp('***下面是进行新信息的GM(1,1)模型预测的详细过程***')
    result2 = new_gm11(train_x0, test_num);
    disp(' ')
    disp('***下面是进行新陈代谢的GM(1,1)模型预测的详细过程***')
    result3 = metabolism_gm11(train_x0, test_num);
    
    disp(' ')
    disp('------------------------------------------------------------')
    test_year = year(end-test_num+1:end);
    figure(3)
    plot(test_year,test_x0,'o-',test_year,result1,'*-',test_year,result2,'+-',test_year,result3,'x-')
    grid on
    set(gca, 'xtick', year(end-test_num+1):1:year(end))
    legend('试验组的真实数据', '传统GM(1,1)预测结果', '新信息GM(1,1)预测结果', '新陈代谢GM(1,1)预测结果')
    xlabel('年份')
    ylabel('排污总量')
    
    SSE1 = sum((test_x0-result1).^2);
    SSE2 = sum((test_x0-result2).^2);
    SSE3 = sum((test_x0-result3).^2);
    disp(['传统GM(1,1)对于试验组预测的误差平方和为' num2str(SSE1)])
    disp(['新信息GM(1,1)对于试验组预测的误差平方和为' num2str(SSE2)])
    disp(['新陈代谢GM(1,1)对于试验组预测的误差平方和为' num2str(SSE3)])
    if SSE1 < SSE2 & SSE1 < SSE3
    	choose = 1;
    elseif SSE2 < SSE3
    	choose = 2;
   	else
   		choose = 3;
    end
    
    Model = {'传统GM(1,1)模型', '新信息GM(1,1)模型', '新陈代谢GM(1,1)模型'};
	disp(['因为',Model(choose),'的误差平方和最小，所以我们应该选择其进行预测'])
    disp('------------------------------------------------------------')
    predict_num = input('请输入你要往后面预测的期数： ');
    [result, x0_hat, relative_residuals, eta] = gm11(x0, predict_num);
    if choose == 2
		result = new_gm11(x0, predict_num);
    end
    if choose == 3
		result = metabolism_gm11(x0, predict_num);
	end
	result
end

figure(4)
subplot(2, 1, 1)
plot(year(2:end), relative_residuals, '*-') 
grid on
legend('相对残差') 
xlabel('年份')
set(gca,'xtick',year(2:1:end))
subplot(2, 1, 2)
plot(year(2:end), eta, 'o-')
grid on
legend('级比偏差') 
xlabel('年份')
set(gca, 'xtick', year(2:1:end))
disp(' ')
disp('****下面将输出对原数据拟合的评价结果***')

% < 0.1 不错 < 0.2 可接受
average_relative_residuals = mean(relative_residuals);  % 计算平均相对残差 mean函数用来均值
disp(['平均相对残差为' num2str(average_relative_residuals)])
average_eta = mean(eta);   % 计算平均级比偏差
disp(['平均级比偏差为' num2str(average_eta)])
disp(' ')
disp('------------------------------------------------------------')

figure(5)
plot(year, x0, '-o', year, x0_hat, '-*m', year(end)+1:year(end)+predict_num, result, '-*b')
hold on
plot([year(end), year(end)+1], [x0(end), result(1)], '-*b')
legend('原始数据','拟合数据','预测数据')
set(gca, 'xtick', [year(1):1:year(end)+predict_num])
xlabel('年份')
ylabel('排污总量')
```



# 例题演示

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210427200049434.png)

## SPSS 操作

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210514210415804.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210514210603197.png)

## 例题1. 销售数据预测

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428105409192.png)

数据为季度数据（有四个周期），从图中看出也有季节性波动，即第二季度的销量较高，第四季度较低。

根据时间序列图可知数据不平稳，有向上的趋势。

SPSS 的专家建模给出的最合适的模型是温特加法模型，意味着原时间序列数据含有线性趋势和稳定的季节成分，我们可以使用加法时间序列分解。

SPSS 也会对发现的异常值使用序列平均值来替代。

注：

- 预测值和拟合值是不相同的，预测值是将样本外年份的数据带入模型计算得到的，而拟合值是将样本的年份重新带入模型计算得到。
- 保留残差的ACF和PACF图形可以帮助我们判断残差是否为白噪声，即该时间序列是否能被模型识别完全。
- 一般比较两个模型的好坏，我们可以使用平稳的R方（文档上翻译成了固定的R方）或者标准化BIC（BIC准则），这两个指标既考虑了拟合的好坏，又考虑了模型的复杂度
- R方可用来反映线性模型拟合的好坏，越接近于1拟合的越准确

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428112219505.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428112250580.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428112351973.png)



## 例题2. 人口数据预测

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428112742127.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428112800341.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428130305431.png)

## 例题3. 上证指数预测

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428130416367.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428130446738.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428130528074.png)

剔除异常值后进行预测：

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428130748041.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428130820019.png)

## 例题4. GDP增速预测

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428131014195.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428131052801.png)

预测 **两要**：一要结合背景；二要合理假设，预测 **两不要**：不要硬套模型；不要不做解释

GDP 还受到了国内政策和其他社会因素的影响。

## 例题5. 深成B指时间序列预测

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428150820881.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428150845208.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428150947333.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428151022241.png)

太多的滞后项会增加预测的 **误差** ，太少的滞后项又会 **遗失** 部分相关信息。经验和理论知识通常是用来决定滞后项阶数的最好方式，然而，依然存在着一些准则帮助我们确定滞后的阶数。为了确定哪个模型拟合效果最好，我们分别估计出了这四种模型，并给出了对应的AIC和BIC值，我们认为AIC与BIC值较小，模型拟合效果较好。

|                     | AIC     | BIC      |
| ------------------- | ------- | -------- |
| Model1：ARMA（3,3） | 3575.15 | 3614.903 |
| Model2：ARMA（8,8） | 3567.47 | 3656.915 |
| Model3：ARMA（3,8） | 3576.66 | 3641.258 |
| Model4：ARMA（8,3） | 3575.39 | 3639.992 |

这四个模型中应选取Model1，即ARMA（3,3）模型。此时，AIC值和BIC值的平均值最小。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428151626110.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428151730932.png)

检验残差是否为白噪声，使用 Ljung‐Box Q 检验，来检验ARMA模型的有效性，滞后12项的检验值的P值大于0.05，在5%的显著性水平下并不能拒绝原假设。故可以认为通过白噪声检验，即我们认为回归得到的残差不存在较明显的相关性，因此模型有效性较好。

接下来再用LM检验是否存在 GARCH 误差。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428151857264.png)

再通过 GARCH 调整参数，选择使用带有GARCH(1,1) 且 $v_t$ 服从t分布的扰动项的 ARMA(3,3) 模型进行估计。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210428152359223.png)

```stata
insheet using "Bindex.csv"
gen datevar = date(date, "YMD")
format datevar %td
label variable datevar "日期"
tsset datevar
gen time = _n // 系统记录到后台的观测值的个数
tsset time

line index datevar
gen r = 100 * (index - L.index) / L.index // L 为 lag 滞后项的缩写
summarize r
line r datevar

// ADF PADF 检测
dfuller r
ac r,lags(20) // 自相关系数图
pac r,lags(20) 

set matsize 1500
arima r,arima(3,0,3)   // 用ARIMA(3,0,3)模型对r进行估计
estat ic   // 得到AIC和BIC，用于选择合适的模型（选小原则）
arima r,arima(8,0,8)
estat ic
arima r,arima(3,0,8)
estat ic
arima r,arima(8,0,3)
estat ic

// 残差分布直方图
arima r,arima(3,0,3)
predict residess, residuals
hist residess,norm freq

// 残差白噪声序列，检验方法为Q检验
wntestq residess, lag(12)
gen ressq = residess^2
wntestq ressq, lag(12)

// LM检验：是否存在ARCH误差
reg ressq l.ressq l2.ressq l3.ressq l4.ressq l5.ressq
gen LM_STAT=e(N)*e(r2) // 计算LM统计量
display LM_STAT
display chiprob(e(df_m),LM_STAT) // 计算 p 值

// 利用AIC BIC选择合适的模型进行估计 
// 注意：扰动项的分布在金融数据中常服从t分布
// 正态分布下GARCH(1,1)估计
arch r,arima(3 0 3) arch(1) garch(1)
estat ic
// t分布下GARCH(1,1)估计
arch r,arima(3 0 3) arch(1) garch(1) distribution(t 3)  // 自由度为3的t分布
estat ic
arch r,arima(3 0 3) arch(2) garch(2)
estat ic
arch r,arima(3 0 3) arch(2) garch(2) distribution(t 3)
estat ic

// 得到拟合结果，并进行预测
arch r,arima(3 0 3) arch(1) garch(1) distribution(t 3)
tsappend, add(10)  // 将时间延长10期
predict result // 对数据进行预测
tsline result r, legend(label(1 "预测值")  label(2 "真实值"))
```

