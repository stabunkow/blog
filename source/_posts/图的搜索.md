---
title: 图的搜索
date: 2021-03-01 10:25:41
tag: [OJ, 图论, 图的搜索]
---

# 图的搜索

## 深度优先搜索 DFS

DFS 是用回溯 + 剪枝来实现搜索，对一条路径搜索到底，直到碰到死路再回溯回来搜索其他路径，用递归比较方便实现。

**代码：** 使用该代码说明从起点到终点是否存在一条路径。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAX_N 100

int n, m, sx, sy;
char mmap[MAX_N + 5][MAX_N + 5];
int dir[4][2] = {0,1,1,0,0,-1,-1,0};

int dfs(int x, int y) {
    for (int i = 0; i < 4; ++i) {
        int xx = x + dir[i][0];
        int yy = y + dir[i][1];
        if (mmap[xx][yy] == 'T') {
            return 1;
        }
        if (mmap[xx][yy] == '.') {
            mmap[xx][yy] = '#';
            if (func(xx, yy)) {
                return 1;
            }
        }
    }
    return 0;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 'S') {
                sx = i, sy = j;
            }
        }
    }
    if (dfs(sx, sy) == 1) {
        cout << "YES" << endl;
    } else {
        cout << "NO" << endl;
    }
    return 0;
}
```

## 广度优先搜索 BFS

BFS 用分支界限法的思想来实现搜索，使用队列以广度优先，可以记录路径长度最小损耗值。

**代码：** 使用该代码说明从起点到终点是否存在一条路径，并输出最小路径值。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAX_N 100

struct node {
    int x, y, step;
};

int n, m, sx, sy;
int dir[4][2] = {0,1,1,0,0,-1,-1,0};
char mmap[MAX_N + 5][MAX_N + 5];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> mmap[i][j];
            if (mmap == 'S') {
                sx = i, sy = j;
            }
        }
    }
    queue<node> que;
    que.push((node) {sx,sy,0});
    while (!que.empty()) {
        node temp = node.front();
        que.pop();
        int x = temp.x + dir[i][0];
        int y = temp.y + dir[i][1];
        if (mmap[x][y] == 'T') {
            cout << temp.step + 1 << endl;
            return 0;
        }
        if (mmap[x][y] == '.') {
            mmap[x][y] = 0;
            que.push((node){x,y,temp.step + 1});
        }
    }
    cout << "NO" << endl;
    return 0;
}
```

## A* 算法

以网格地图搜索为例，从起点往终点搜索，使用广度优先搜索，发现存在不必要的搜索方向情况。

A* 算法是一种启发式搜索算法，使用起点出发的距离与到终点预估距离之和作为搜索考虑值。

**代码：** 使用该代码打印从起点到终点的路径详情。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 2000

struct node {
    int x, y, step; // step 从起点已出发的距离
    double h; // 到目标的预估距离
    bool operator< (const node &b) const {
        return this->step + this->h > b.step + b.h;
    }
};

int n, m, sx, sy, ex, ey, cnt;
// 8方向搜索
int dir[8][2] = {0,1,1,0,0,-1,-1,0,1,1,1,-1,-1,1,-1,-1};
char mmap[MAX_N + 5][MAX_N + 5];

double func(int x, int y) {
    int a = ex - x, b = ey - y;
    return sqrt(a * a + b * b);
}

// 打印路径详情
void p() {
    cout << "----------------------------------------" << endl;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cout << mmap[i][j];
            if (mmap[i][j] == 'x') {
                mmap[i][j] = 'X';
            }
        }
        cout << endl;
    }
    cout << "++++++++++++++++++++++++++++++++++++++++" << endl;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> mmap[i][j];
            if (mmap[i][j] == 'S') {
                sx = i, sy = j;
            }
            if (mmap[i][j] == 'T') {
                ex = i, ey = j;
            }
        }
    }
    // 使用最小堆，以最小损耗优先的方式搜索解空间
    priority_queue<node> que;
    que.push((node) {sx, sy, 0, func(sx, sy)});
    while (!que.empty()) {
        node temp = que.top();
        que.pop();
        for (int i = 0; i < 8; ++i) {
            int x = temp.x + dir[i][0];
            int y = temp.y + dir[i][1];
            if (mmap[x][y] == 'T') {
                cout << temp.step + 1 << endl;
                return 0;
            }
            if (mmap[x][y] == '.') {
                mmap[x][y] = 'x';
                que.push((node) {x, y, temp.step + 1, func(x, y)});
                cnt++;
                if (cnt % 10 == 0) {
                    p();
                }
            }
        }
    }
    cout << -1 << endl;
    return 0;
}
```

**输入：**

```
10 40
........................................
........................................
.........S..............................
........................................
........................................
........................................
......###############...................
........................................
.............T..........................
........................................
```

**输出：**

```
----------------------------------------
........................................
........xxx.............................
........xSxx............................
........xxxxx...........................
.........xxxxx..........................
..........xxxx..........................
......###############...................
........................................
.............T..........................
........................................
+++++++++++++++++++++++++++++++++++++++

...

----------------------------------------
......xXXXXXXXxx........................
.....xXXXXXXXXXx........................
.....xXXXSXXXXXXx.......................
.....xXXXXXXXXXXXx......................
.....xXXXXXXXXXXXx......................
....xXXXXXXXXXXXXx......................
....xX###############...................
....xxxx................................
......xx.....T..........................
........................................
++++++++++++++++++++++++++++++++++++++++
```

运行后，会看到每步输出按照预期结果前进。但是 A* 算法仍有部分局限情况，考虑以下输入算例，还是会对死路进行遍历，部分上古游戏操作单位寻路后运行结果也是如此。

```
----------------------------------------
........................................
........XXX.............................
......#.XSXxx#..........................
......#.XXXXx#..........................
......#..xXxx#..........................
......#..xxxx#..........................
......########..........................
........................................
.............T..........................
........................................
++++++++++++++++++++++++++++++++++++++++

...

----------------------------------------
.......XXXXXXXx.........................
......XXXXXXXXXx........................
......#XXSXXX#Xx........................
......#XXXXXX#xx........................
......#XXXXXX#xx........................
......#XXXXXX#xx........................
......########x.........................
........................................
.............T..........................
........................................
++++++++++++++++++++++++++++++++++++++++
```