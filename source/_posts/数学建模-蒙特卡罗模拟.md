---
title: 数学建模-蒙特卡罗模拟
date: 2021-05-14 20:01:06
mathjax: true
tag: [数学建模]
---



# 蒙特卡罗模拟

蒙特卡罗方法又称统计模拟法，是一种随机模拟方法，以概率和统计理论方法为基础的一种计算方法，是使用随机数（或更常⻅的伪随机数）来解决很多计算问题的方法。将所求解的问题同一定的概率模型相联系，用电子计算机实现统计模拟或抽样，以获得问题的近似解。

由大数定理可知，当样本容量足够大时，事件的发生频率即为其概率。

## 例题1：投针实验

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210424105525942.png)



```matlab
l = 0.520; % 针的长度
a = 1.314; % 宽度距离 （大于针的长度 l 即可）
n = 1000000; % 做 n 次投针实验
m = 0; % 与平行线相交的次数
x = rand(1, n) * a / 2; % 服从均匀分布生成，扔针的距离是随机的，x 代表针的中点到最近平行线的距离
phi = rand(1, n) * pi; % 假设模拟真实投针，扔针的角度是随机的
for i = 1:n
	if x(i) <= l / 2 * sin(phi(i))
		m = m + 1;
	end
end
p = m / n;
mypi = (2 * l) / (a * p); % 根据公式得我们所计算的 pi
disp(['蒙特卡罗方法得到pi为：' num2str(mypi)])
% 可以进行多次实验再求平均
```

## 例题2：三门问题

你参加一档电视节目，节目组提供了ABC三扇⻔，主持人告诉你，其中一扇⻔后边有辆汽⻋，其它两扇⻔后是空的。假如你选择了B⻔，这时，主持人打开了C⻔，让你看到C⻔后什么都没有，然后问你要不要改选A⻔？

本题问题得实质是因为概率空间不同。

```matlab
n = 100000; % 模拟次数
a = 0; % 不改变主意时赢得汽车的次数
b = 0; % 改变主意时赢得汽车的次数
c = 0; % 失败的次数
for i = 1:n
	x = randi([1 3]);
	y = randi([1 3]); % 随机生成一个 1-3 的整数
	change = randi([0, 1]);
	if x == y
		if change == 0
			a = a + 1;
		else
			c = c + 1;
	else
		if change == 0
			c = c + 1;
		else
			b = b + 1;
		end
	end
end
disp(['蒙特卡罗方法得到的不改变主意时的获奖概率为：' num2str(a/n)])
disp(['蒙特卡罗方法得到的改变主意时的获奖概率为：' num2str(b/n)])
disp(['蒙特卡罗方法得到的没有获奖的概率为：' num2str(c/n)])
```

## 例题3：排队问题

假设某银行工作时间只有一个服务窗口，工作人员只能逐个的接待顾客。当来的顾客较多时，一部分顾客就需要排队等待。    

假设：1) 顾客到来的间隔时间服从参数为0.1的指数分布   2) 每个顾客的服务时间服从均值为10，方差为4的正态分布(单位为分钟，若服务时间小于1分钟，则按1分钟计算)   3) 排队按先到先服务的规则，且不限制队伍的⻓度，每天工作时⻓为8小时。     

试回答下面的问题：1) 模拟1个工作日，在这个工作日共接待了多少客户，客户平均等待的时间为多少?   2) 模拟100个工作日，计算出平均每日接待客户的个数以及每日客户的平均等待时⻓。

指数分布，符合自然界使用寿命长度，参数为 $\lambda$, 均值为 $1/\lambda$

```matlab
%% 问题1
tic % 计算时间
i = 1; % 第 i 个客户
w = 0; % 等待时间总和
x(1) = exprnd(10); % 第0个客户和第1个客户到达时间间隔
c(1) = x(1);
b(1) = c(1); % 开始服务时间
while b(i) <= 480
	y(i) = normrnd(10, 2) % 服从均值10，方差4的正态分布的服务时间
	if y(i) < 1
		y(i) = 1;
	end
	e(i) = b(i) + y(i);
	wait(i) = b(i) - c(i); %　开始服务时间减去到达时间
	w = w + wait(i);
	i　＝　i + 1;
	x(i) = exprnd(10);
	c(i) = c(i-1) + x(i);
	b(i) = max(c(i), e(i-1));
end
n = i - 1; % 共服务的人的个数
t = w / n;
disp(['银行一天8小时一共服务的客户人数为: ' num2str(n)])
disp(['客户的平均等待时间为: ' num2str(t)])
toc

%% 问题2
day = 100
n = zeros(day, 1);
t = zeros(day, 1);
for k = 1:day
	i = 1;
	w = 0;
	x(1) = exprnd(10);
	c(1) = x(1);
	b(1) = c(1);
	while b(i) <= 480
		y(i) = normrnd(10, 2);
		if y(i) < 1
			y(i) = 1;
		end
		e(i) = b(i) + y(i);
		wait(i) = b(i) - c(i);
		w = w + wait(i);
		i = i + 1;
		x(i) = exprnd(10);
		c(i) = c(i-1) + x(i);
		b(i) = max(c(i), e(i-1));
	end
	n(k) = i - 1;
	t(k) = w / n(k);
end
disp([num2str(day) '个工作日中，银行每日平均服务的客户人数为: ' num2str(mean(n))])
disp([num2str(day) '个工作日中，银行每日客户的平均等待时间为: ' num2str(mean(t))])
```

## 例题4：有约束的非线性规划问题

取值限定，随机取值

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210424114201566.png)

线性规划问题可有数学方法，找到一个确定的解。

非线性规划往往只能找到局部最优解。

```matlab
n = 1000000;
x1 = unifrnd(20, 30, n, 1); %　在 [20 30] 内均匀分布的随机数
x2 = x1 - 10;
x3 = unifrnd(-10, 16, n, 1);
fmax = -inf;
for i = 1:n
    x = [x1(i) x2(i) x3(i)];
    if (-x(1) + 2*x(2) + 2*x(3) >= 0) & (x(1) + 2*x(2) + 2*x(3) <= 72)
        result = x(1) * x(2) * x(3);
        if result > fmax
            fmax = result;
            X = x;
        end
    end
end
disp(strcat('蒙特卡罗模拟得到的最大值为' num2str(fmax)))
disp('最大值处x1 x2 x3的取值为：')
disp(X)
% 再缩小范围重新模拟得到更加精确的取值
```

## 例题5：买书问题

取值限定，随机取值

0-1 规划问题（非背包问题限制）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210424114042207.png)

```matlab
min_money = +Inf;
min_result = randi([1, 6], 1, 5);
n = 100000;
M = [
	18  39  29  48	59
	24	45	23	54	44
	22	45	23	53	53
    28	47	17	57	47
    24	42	24	47	59
    27	48	20	55	53
];
freight = [10 15 15 10 10 15];
for k = 1:n
	result = randi([1, 6], 1, 5);
	index = unique(result);
	money = sum(freight(index));
	for i=1:5
		money = money + M(result(i), i);
	end
	if money < min_money
		min_money = money;
		min_result = result;
	end
end
min_money
min_result
```

## 例题6：导弹追踪问题

纯模拟问题，设置时间间隔。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210424133305195.png)

```matlab
v = 200;
dt = 0.0000001;
x = [0, 20]; % 导弹和船的坐标
y = [0, 0];
t = 0; % 飞行时间
d = 0; % 飞行距离
m = sqrt(2) / 2; % 定为 sin45 常量
dd = sqrt((x(2) - x(1)) ^ 2 + (y(2) - y(1)) ^ 2);
for i = 1:2
    plot(x(i), y(i), '.k', 'MarkerSize', 1)  % 画出导弹和B船所在的坐标，点的大小为1，颜色为黑色(k)，用小点表示
    grid on
    hold on  
end
axis([0 30 0 10]) % 固定x轴的范围为0-30  固定y轴的范围为0-10
k = 0;  % 引入一个变量  为了控制画图的速度
while (dd >= 0.001) {
	t = t + dt;
	d = d + 3 * v * dt;
	x(2) = 20 + t * v * m;
	y(2) = 20 + t * v * m;
	dd = sqrt((x(2) - x(1)) ^ 2 + (y(2) - y(1)) ^ 2);
	tan_alpha = (y(2) - y(1)) / (x(2) - x(1));
	cos_alpha = sqrt(1 / (1 + tan_alpha ^ 2));
	sin_alpha = sqrt(1 - cos_alpha ^ 2);
	x(1) = x(1) + 3 * v * dt * cos_alpha;
	y(1) = y(1) + 3 * v * dt * sin_alpha;
	k = k + 1;
	if mod(k, 500) == 0
		for i = 1:2
            plot(x(i), y(i), '.k', 'MarkerSize', 1)
            hold on % 不关闭图形，继续画图
        end
        pause(0.001)
	end
	
    if d > 50 
        disp('导弹没有击中B船')
        break
    end
    if d <= 50 && dd < 0.001 
    	disp(['导弹飞行' num2str(d) '单位后击中B船'])
        disp(['导弹飞行的时间为' num2str(t*60) '分钟'])
    end
}

```

## 例题7：旅行商问题

取值限定，随机取值，节点数多时难以到达最优结果。

部分优化方案，先运行聚类算法，再运行蒙特卡洛模拟。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210424135533997.png)

```matlab
coord = [
		0.6683 0.6195 0.4 0.2439 0.1707 0.2293 0.5171 0.8732 0.6878 0.8488;
        0.2536 0.2634 0.4439 0.1463 0.2293 0.761  0.9414 0.6536 0.5219 0.3609
  	]';
n = size(coord, 1);
figure(1)
plot(coord(:, 1),coord(:, 2), 'o')
for i = 1:n
    text(coord(i, 1) + 0.01, coord(i, 2) + 0.01, num2str(i)) % 在图上标上城市的编号
end
hold on

d = zeros(n);
for i = 2:n  
    for j = 1:i  
        coord_i = coord(i, :);   
        x_i = coord_i(1);     
        y_i = coord_i(2);  % 城市i的横坐标为x_i，纵坐标为y_i
        coord_j = coord(j, :);   
        x_j = coord_j(1);     
        y_j = coord_j(2);  % 城市j的横坐标为x_j，纵坐标为y_j
        d(i,j) = sqrt((x_i - x_j) ^ 2 + (y_i - y_j) ^ 2);   % 计算城市i和j的距离
    end
end
d = d+d'; % 矩阵对称
min_result = +inf;
min_path = [1:n]; 
N = 10000000; % 模拟次数
for i = 1:N  % 开始循环
    result = 0;
    path = randperm(n);  % 生成一个1-n的随机打乱的序列
    for i = 1:n-1 
        result = d(path(i), path(i+1)) + result;  % 按照这个序列不断的更新走过的路程这个值
    end
    result = d(path(1), path(n)) + result;  % 别忘了加上从最后一个城市返回到最开始那个城市的距离
    if result < min_result
        min_path = path;
        min_result = result;
    end
end
min_result
min_path
min_path = [min_path, min_path(1)];
n = n + 1;
for i = 1:n-1 
    j = i + 1;
    coord_i = coord(min_path(i), :);   
    x_i = coord_i(1);     
    y_i = coord_i(2); 
    coord_j = coord(min_path(j), :);   
    x_j = coord_j(1);     
    y_j = coord_j(2);
    plot([x_i, x_j],[y_i, y_j], '-')    % 每两个点就作出一条线段，直到所有的城市都走完
    pause(0.5)  % 暂停0.5s再画
    hold on
end
```

