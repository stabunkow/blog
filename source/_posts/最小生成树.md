---
title: 最小生成树
date: 2021-03-02 21:25:41
tag: [OJ, 图论, 最小生成树, 并查集]
---



# 最小生成树

最小生成树是极小连通子图，可以用 Kruskal 算法或者 Prim 算法求出，采用贪心算法的思想。

使用该例题说明：[最小生成树](https://www.luogu.com.cn/problem/P3366)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210302195909075.png)

**输入**

```
4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
```

**输出**

```
7
```

## Kruskal 算法

通过边排序从低到高，然后逐渐把边加入图中，使用并查集，直到边与边之间连通打通次数迭代到 $n - 1$ 次（$n$ 为点的数量），所有边都连通。时间复杂度 $O(n \times m)$ , $n$ 为点的数量，$m$ 为边的数量。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 5000
#define MAX_M 200000

struct edge {
    int s, e, v;
    bool operator<(const edge &b) const {
        return this->v < b.v;
    }
};

// kruskal 算法对双向边仅需存一次
edge edg[MAX_M + 5];
int n, m, ans, my_union[MAX_N + 5], cnt;

// 使用并查集方便找到边集合间的关系
int find_fa(int x) {
    if (my_union[x] == x) {
        return x;
    }
    return my_union[x] = find_fa(my_union[x]);
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        my_union[i] = i;
    }
    for (int i = 0; i < m; ++i) {
        cin >> edg[i].s >> edg[i].e >> edg[i].v;
    }
    // 排序复杂度 mlogm
    sort(edg, edg + m);
    // 并查关系复杂度 n * m
    for (int i = 0; i < m; ++i) {
        int fa = find_fa(edg[i].s), fb = find_fa(edg[i].e);
        if (fa != fb) {
            ans += edg[i].v;
            my_union[fa] = fb;
            cnt++;
            if (cnt == n - 1) break;
        }
    }
    if (cnt == n - 1) {
        cout << ans << endl;
    } else {
        cout << "orz" << endl;
    }
    
    return 0;
}

```

## Prim 算法

通过点到点之间的关系，查找已连通点的集合向外搜索尚未连接的点的关系，将最近的点加入到已连通集合中，直到所有点都在集合中。时间复杂度为 $O(n^2)$ ，$n$ 为点的数量。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 5000
#define MAX_M 200000

struct node {
    int now, v;
    bool operator< (const node &b) const {
        return this->v > b.v;
    }
};

struct edge {
    int e, v, next;
};

edge edg[MAX_M * 2 + 5];
int n, m, ans, edg_cnt, head[MAX_N + 5], cnt, mark[MAX_N + 5];

void add_edg(int a, int b, int c) {
    edg[edg_cnt].e = b;
    edg[edg_cnt].v = c;
    edg[edg_cnt].next = head[a];
    head[a] = edg_cnt++;
}

int main() {
    memset(head, -1, sizeof(head));
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        add_edg(a, b, c);
        add_edg(b, a, c);
    }
	
    // 与 Djikstra 算法相似，使用堆来优化查找关系
    priority_queue<node> que;
    que.push((node){1, 0});
    while (!que.empty()) {
        node temp = que.top();
        que.pop();
        // 已经连接
        if (mark[temp.now] == 1) continue;
        mark[temp.now] = 1;
        ans += temp.v;
        cnt++;
        if (cnt == n) break;
        for (int i = head[temp.now]; i != -1; i = edg[i].next) {
            int e = edg[i].e, v = edg[i].v;
            // 尚未连接
            if (mark[e] == 0) {
                que.push((node) {e, v});
            }
        }
    }
    
    if (cnt == n) {
        cout << ans << endl;
    } else {
        cout << "orz" << endl;
    }

    return 0;
}
```



