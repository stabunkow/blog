---
title: 数学建模-图论
date: 2021-05-14 10:25:41
mathjax: true
tag: [数学建模, 图论, 最短路算法]
---

# 图论

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210514161317781.png)

```matlab
% 无向图
s1 = [1,2,3,4];
t1 = [2,3,1,1];
G1 = graph(s1, t1);
plot(G1)

% 无向图带权重
s = [1,2,3,4];
t = [2,3,1,1];
w = [3,8,9,2];
G = graph(s, t, w);
plot(G, 'EdgeLabel', G.Edges.Weight, 'linewidth', 2) 
set(gca, 'XTick', [], 'YTick', [] );  % 不显示坐标

% 有向图带权重
s = [1,2,3,4];
t = [2,3,1,1];
w = [3,8,9,2];
G = digraph(s, t, w);
plot(G, 'EdgeLabel', G.Edges.Weight, 'linewidth', 2) 
set( gca, 'XTick', [], 'YTick', [] );  
```

# 最短路算法

## Dijkstra 算法

单源最短路算法。

即贪心思想，每次确定到一个点的最短距离，必可以从已到的点中获取信息，生成接下来一个到新的一个点的最短距离。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210514162330956.png)

## Bellman‐Ford 算法

单源最短路算法。

Bellman‐Ford 算法基于规划思想，不再将节点区分为是否已访问的状态，利用循环来进行更新权重的，且每循环一次，贝尔曼福特算法都会更新所有的节点的信息，根据这条边的起点的答案，再加上边的权值，去更新边的终点的答案，该算法不支持含有负权回路的图。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210514163000151.png)

## Matlab 使用

```matlab
s = [9 9 1 1 2 2 2 7 7 6 6  5  5 4];
t = [1 7 7 2 8 3 5 8 6 8 5  3  4 3];
w = [4 8 3 8 2 7 4 1 6 6 2 14 10 9];
G = graph(s,t,w);
plot(G, 'EdgeLabel', G.Edges.Weight, 'linewidth', 2) 
set( gca, 'XTick', [], 'YTick', [] );  
[P, d] = shortestpath(G, 9, 4) % 目标起点到终点 输出路径和距离值

% 在图中高亮我们的最短路径
myplot = plot(G, 'EdgeLabel', G.Edges.Weight, 'linewidth', 2);
highlight(myplot, P, 'EdgeColor', 'r')

% 求出求解过程中的最短路径矩阵
D = distances(G)
D(1,2)  % 1 -> 2的最短路径
D(9,4)  % 9 -> 4的最短路径

% 找出给定范围内的所有点  nearest(G,s,d)
% 返回图形 G 中与节点 s 的距离在 d 之内的所有节点
[nodeIDs, dist] = nearest(G, 2, 10)  
```

## Floyd 算法

多源最短路算法。

令 D(X,Y) 表示 X 和 Y 两点之间的最短距离，那么假设现在有一个起点 A 和终点 B，那么对于其他任意的中间点 M：D(A,B) ≤ D(A,M) + D(M,B) 

其算法核心的步骤由三层循环构成：

```matlab
function [dist,path] = Floyd_algorithm(D)
%% 该函数用于求解一个权重邻接矩阵任意两个节点之间的最短路径
% 输入：
%        D是权重邻接矩阵
% 输出：
%        dist是最短距离矩阵，表示两个节点的最短距离
%        path是路径矩阵，最短路径要经过的节点
    n = size(D,1);
    dist = D;

    path = zeros(n);
    for j = 1:n
        path(:,j) = j;   % 将第j列的元素变为j
    end
    for i = 1:n
        path(i,i) = -1;  % 将主对角线元素变为-1
    end

    for k=1:n 
       for i=1:n
          for j=1:n
              if dist(i,j) > dist(i,k) + dist(k,j)
                 dist(i,j) = dist(i,k) + dist(k,j);
                 path(i,j) = path(i,k);   
                 % path(i, j) = k
                 % 或起点为j，终点为i的两个节点之间的最短路径要经过的节点为 k
              end
          end
       end
    end
end

function [] = print_path(path,dist,i,j)
%% 该函数的作用是打印从i到j经过的最短路径
% 输入：
%        path是使用floyd算法求出来的路径矩阵
%        dist是使用floyd算法求出来的最短距离矩阵
%        i是起始节点的编号
%        j是终点节点的编号

    if i == j
        warning('起点和终点相同')
        return;
    end
    if path(i,j) == j   
        if dist(i,j) == Inf
            disp(['从' num2str(i) '到' num2str(j) '没有路径可以到达'])
        else
            disp(['从' num2str(i) '到' num2str(j) '的最短路径为'])
            disp([num2str(i) ' ---> ' num2str(j)])
            disp(['最短距离为' num2str(dist(i,j))])
        end
    else  % 经过了其他节点：
        k = path(i,j);
        result = [num2str(i) ' ---> '];
        while k ~= j  % 只要k不等于j, 就一直循环下去
            result = [result num2str(k) ' ---> ' ];
            k = path(k,j);
        end
        result = [result num2str(k)];
        disp(['从' num2str(i) '到' num2str(j) '的最短路径为'])
        disp(result)
        disp(['最短距离为' num2str(dist(i,j))])
    end

end

n = 5; 
D = ones(n) ./ zeros(n);  % 全部元素初始化为Inf
for i = 1:n
    D(i,i) = 0;  % 主对角线元素为0
end
D(1,2) = 3;
D(1,3) = 8;
D(1,5) = -4;
D(2,5) = 7;
D(2,4) = 1;
D(3,2) = 4;
D(4,3) = -5;
D(5,4) = 6;
D(4,1) = 2;

[dist,path] = Floyd_algorithm(D)

print_path(path,dist,1,5)
print_path(path,dist,1,4)
print_path(path,dist,3,1)
```

