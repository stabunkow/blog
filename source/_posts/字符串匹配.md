---
title: 字符串匹配
date: 2021-03-04 14:25:41
mathjax: true
tag: [OJ, 哈希, 字符串匹配]
---

# 字符串匹配

## 完全匹配

使用哈希快速匹配算法：可以采用哈希的思想，为字符串计算哈希值，看是否相等。通过哈希操作判断两个字符串是否 **相等** ，哈希值不同的话，两个值一定不相等，密码加密匹配的过程就是使用哈希匹配。

哈希计算公式 $H = (\sum\limits_{k=0}^{n-1} C_k \times base^k) \% P$

## 单模匹配

使用一个主串 $S$，来检查该主串对模式串 $T$ 的匹配情况。

### 暴力匹配

又名 Brute-Force 算法，对齐模式串和主串的每一位。时间复杂度 $O(n \times m)$，$n$ 为主串长度，$m$ 为模式串长度。

#### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

// 匹配成功返回主串匹配位置，匹配失败返回 -1
int brute_force(const char *s, const char *t) {
    for (int i = 0; s[i]; ++i) {
        int flag = 1;
        for (int j = 0; t[j]; ++j) {
            if (s[i + j] == t[j]) continue;
            flag = 0;
            break;
        }
        if (flag == 1) return i;
    }
    return -1;
}

int main() {
    char t[1000], s[1000];
    cin >> t >> s;
    cout << brute_force(s, t) << endl;
    return 0;
}
```

### KMP 算法

KMP 算法通过对这个词在不匹配时本身所包含的信息来确定下一个匹配将在哪里开始发现，避免重新检查先前匹配的字符，提高程序运行效率。在匹配前，会预处理模式串 $T$ ，得到一个 $fail$ 数组。利用 $fail$ 数组，可以在失配的时候，跳到上一个视为后缀相同连续可以匹配串的位置。 KMP 算法的时间复杂度为 $O(n + m)$ ，$n$ 为主串长度，$m$ 为模式串长度。

例如对于模式串 `aababaab`，$fail$ 数组为：

|  a   |  a   |  b   |  a   |  b   |  a   |  a   |  b   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  -1  |  0   |  -1  |  0   |  -1  |  0   |  1   |  2   |

#### 代码实现1

```cpp
#include <bits/stdc++.h>

using namespace std;

void get_fail(const char *t, int *fail) {
    fail[0] = -1;
    for (int i = 1, j = -1; t[i]; ++i) {
        while (j != -1 && t[j + 1] == t[i]) j = fail[j];
        if (t[j + 1] == t[i]) ++j;
        fail[i] = j;
    }
    return ;
}

int kmp(const char *s, const char *t) {
    int m = strlen(t);
    int *fail = (int *) malloc(sizeof(int) * (m + 1));
    get_fail(t, fail);
    for (int i = 0, j = -1; s[i]; ++i) {
        while (j != -1 && t[j + 1] != s[i]) j = fail[j];
        if (t[j + 1] == s[i]) ++j;
        if (t[j + 1] == 0) return i - j; // j == m - 1
    }
    free(fail);
    return -1;
}

int main() {
    char t[1000], s[1000];
    cin >> t >> s;
    cout << kmp(s, t) << endl;
    return 0;
}
```

#### 代码实现2

以有限状态机来去理解，每读入一个字符，进行状态跳转，改变 j 的值，直到到达终止状态，回退箭头就是 $fail$ 数组指向的位置。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210306133546363.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int get_next(const char *t, int &j, char c, int *next) {
    while (j != -1 && t[j + 1] != c) j = next[j];
    if (t[j + 1] == c) j++;
    return j;
}

int kmp(const char *s, const char *t) {
    int m = strlen(t);
    int *next = (int *) malloc(sizeof(int) * (m + 1));
    next[0] = -1;
    for (int i = 1, j = -1; t[i]; ++i) next[i] = get_next(t, j, t[i], next);
    for (int i = 0, j = -1; s[i]; ++i) {
        if (get_next(t, j, s[i], next) != m - 1) continue;
        return i - j; // j == m - 1
    }
    free(next);
    return -1;
}

int main() {
    char t[1000], s[1000];
    cin >> t >> s;
    cout << kmp(s, t) << endl;
    return 0;
}
```

### Sunday 算法

模式串 $T$ 和 母串 $S$ 适配过程中，出现最后一位字符不匹配，那么用之前模式串中可匹配的最后一位找到母串之后最先出现该字符的位置对齐，模式串与母串重新开始从头匹配。需要进行预处理，保存模式串中各字符最后出现的位置方便对齐操作，直到匹配完成或者出现失配，重复这样的操作。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210306140042259.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210306140109281.png)

#### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

int sunday(const char *s, const char *t) {
    int offset[256];
    int m = strlen(t), n = strlen(s);
    // 需要进行预处理，默认每个字符不出现，记录模式串中各字符出现的最后位置
    for (int i = 0; i < 256; ++i) offset[i] = m + 1;
    for (int i = 0; t[i]; ++i) offset[t[i]] = m - i; // 模式串中字符最后出现的位置，匹配母串时先出现
    for (int i = 0; i + m <= n; i += offset[s[i + m]]) {
        int flag = 1;
        for (int j = 0; t[j] && flag; ++j) {
            flag = (t[j] == s[i + j]);
        }
        if (flag) return i;
    }  
    return -1;
}

int main() {
    char t[1000], s[1000];
    cin >> t >> s;
    cout << sunday(s, t) << endl;
    return 0;
}
```

### Shift-And 算法

对模式串进行预处理，把每一种字符出现的位置，转换成二进制编码来表示。用 $P$ 代表匹配情况，位运算能代表匹配情况，并把最高位 1 的位置视为最长匹配长度，若失配时，还能更新最高匹配位，直到 $P$ 能够匹配到最高位或者失配，重复这样的操作。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210306143354803.png)

#### 代码实现

```cpp
#include <bits/stdc++.h>

using namespace std;

int shift_and(const char *s, const char *t) {
    int d[256] = {0}, m = strlen(t);
    // 预处理
    for (int i = 0; t[i]; ++i) {
        d[t[i]] |= (1 << i);
    }

    // p 表示匹配情况
    int p = 0;
    for (int i = 0; s[i]; ++i) {
        p = (p << 1 | 1) & d[s[i]];
        // 能匹配到最高位
        if (p & (1 << (m - 1))) return i - (m - 1);
    }

    return -1;
}

int main() {
    char t[1000], s[1000];
    cin >> t >> s;
    cout << shift_and(s, t) << endl;
    return 0;
}int shift_and(const char *s, const char *t) {
    int d[256] = {0}, n = 0;
    for (int i = 0; t[i]; n++, i++) {
        d[t[i]] |= (1 << i);
    }
    int p = 0;
    for (int i = 0; s[i]; ++i) {
        p = (p << 1 | 1) & d[s[i]];
        // 用 p 看是否能匹配到最高位 
        if (p & (1 << (n - 1))) return i - n + 1;
    }
    return -1;
}
```

## 多模匹配

使用一个主串 $S$ ，来检查该主串对 $n$ 个长度不一的模式串 $T$ 的匹配情况。

### Trie 字典树

Trie 字典树又称前缀索引树，常用于对大量字符串的检索、去重、数量统计和排序等（**非匹配过程**）。Trie 树利用字符串的公共前缀来建树，结点代表字符，边代表关系。Trie 树的根结点不存字符，下图带下划线的字符结点说明形成了一个终止匹配字符。对于 **字符串排序**，时间复杂度为 $O(n)$，$n$ 为字符串数量。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blog845bba7424838c459b685e9a1a17b06ccd8f96f9.png)

#### 代码实现

输入 $n$ 个字符，然后按字典序输出。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define BASE 26

typedef struct Node {
    int flag; // 1 代表为终止结点
    struct Node *next[BASE];
} Node;

Node *getNewNode() {
    Node *p = (Node *) malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

void insert(Node *p, const char *s) {
    for (int i = 0; s[i]; ++i) {
        int ind = s[i] - 'a';
        if (p->next[ind] == NULL) p->next[ind] = getNewNode();
        p = p->next[ind];
    }
    p->flag = 1; // 插入字符标记为终止字符
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; ++i) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

void output(Node *root, int k, char *s) {
    s[k] = 0;
    if (root->flag) {
        printf("%s\n", s); // 存在字符串，输出
    }
    for (int i = 0; i < BASE; ++i) {
        // 字符不存在
        if (root->next[i] == NULL) continue;
        s[k] = 'a' + i;
        output(root->next[i], k + 1, s); // 字符存在可以继续向下输出
    }
    return ;
}

int main() {
    int n;
    char str[100];
    scanf("%d", &n);
    // 根节点不存字符
    Node *root = getNewNode();
    for (int i = 0; i < n; ++i) {
        scanf("%s", str);
        insert(root, str);
    }
    // 输出所有插入的字符，按照字典序排序
    output(root, 0, str);
    clear(root);
    return 0;
}
```

### AC 自动机

Trie 树的优化，利用 KMP 算法的思想，在建立 Trie 树之后，建立失败指针，快速指向后缀相同的模式串，来优化实现 Trie 树的 **匹配** 过程，匹配失败时通过失败指针来进行下一次匹配，减少去 Trie 树中查找下一个可用来匹配的模式串这样的操作：例如主串对 $she$ 字符串失配后，但若存在 $he$ 串，可立刻用该串来匹配。建立失败指针，需用层序遍历由上到下更新，每个子结点的失败指针需要根据其父结点的失败指针情况建立。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210305155108834.png)

#### 代码实现1

输入 $n$ 个字符，形成字典树，然后用一个主串去看匹配哪些模式串。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define BASE 26

typedef struct Node {
    int flag; // 标记是为词
    const char *str; // 直接存储了对应词，因为通过 fail 数组不会去再回溯找前缀
    struct Node *next[BASE], *fail; 
} Node;

Node *getNewNode() {
    Node *p = (Node *) malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    p->fail = NULL;
    return p;
}

void insert(Node *root, const char *str) {
    for (int i = 0; str[i]; ++i) {
        int ind = str[i] - 'a';
        if (root->next[ind] == NULL) root->next[ind] = getNewNode();
        root = root->next[ind];
    }
    root->flag = 1; // 标记为终止
    root->str = strdup(str);
    return ;
}

void build_ac(Node *root) {
    queue<Node*> que;
    root->fail = NULL; // 根结点的 fail 默认为 NULL

    // 需要使用层次遍历，层层更新
    que.push(root);
    while (!que.empty()) {
        Node *p = que.front();
        que.pop();
        for (int i = 0; i < BASE; ++i) {
            Node *k = p->fail;
            // 不存在子结点，不需要继续构造
            if (p->next[i] == NULL) continue;
            // 举例说明，hop 为 hope 构造失败指针时，hop 失败指针已指向 op，若 ope 存在，可以为 hope 更新失败指针
            // 若 ope 不存在，op 失败指针指向 p，pe 存在，则用 pe 为 hope 更新失败指针
            while (k && k->next[i] == NULL) k = k->fail;
            if (k == NULL) k = root; // 默认指向根结点
            else if (k->next[i]) k = k->next[i];

            p->next[i]->fail = k;
            que.push(p->next[i]); 
        }
    }

    return ;
}

void match(Node *root, const char *text) {
    Node *p = root, *q;
    // p 的匹配过程会随着主串的前进匹配长度会增加或者减少动态变化
    for (int i = 0; text[i]; ++i) {
        int ind = text[i] - 'a';
        while (p && p->next[ind] == NULL) p = p->fail; // 若失败，找到下一个可匹配的模式串
        if (p == NULL) p = root; // 重新返回根结点
        if (p->next[ind]) p = p->next[ind]; // 串或失败指针指向可用的串可以继续向下
        q = p;
        // 快速输出能匹配的模式串，其失败结点后缀相同的子串也能匹配
        while (q) {
            if (q->flag == 1) printf("find : %s\n", q->str);
            q = q->fail;
        }
    }

    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; ++i) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    int n;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; ++i) {
        scanf("%s", str);
        insert(root, str);
    }
    build_ac(root);
    scanf("%s", str);
    match(root, str); // 输出字典树中所有可匹配的模式串
    clear(root);
    return 0;
}
```

#### 代码实现2

发现可以优化原版代码中 建立失败指针、匹配过程返回上一个失败指针的时间。用路径压缩思想，状态转移时若 $next[i]$ 为空，然其指向上一个可匹配的失败指针的目标 $next[i]$，代码书写也更简洁些。缺点是理解比较可能比较困难，对树的销毁还需要额外一些操作。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define BASE 26

typedef struct Node {
    int flag; // 标记是为词
    int tag[BASE]; // 逻辑上把实际 NULL 修改了，遍历删除时要防止回到 root
    const char *str; // 直接存储了对应词，因为通过 fail 数组不会去再回溯找前缀
    struct Node *next[BASE], *fail; 
} Node;

Node *getNewNode() {
    Node *p = (Node *) malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    p->fail = NULL;
    return p;
}

void insert(Node *root, const char *str) {
    for (int i = 0; str[i]; ++i) {
        int ind = str[i] - 'a';
        if (root->next[ind] == NULL) root->next[ind] = getNewNode();
        root->tag[ind] = 1;
        root = root->next[ind];
    }
    root->flag = 1; // 标记为终止
    root->str = strdup(str);
    return ;
}

void build_ac(Node *root) {
    queue<Node*> que;
    root->fail = NULL; // 根结点的 fail 默认为 NULL

    // 经过以下处理除了根节点外的 ->next[i] 不可能为 NULL 
    for (int i = 0; i < BASE; ++i) {
        if (root->next[i] == NULL) {
            root->next[i] = root;
            continue;
        }
        // 只把根节点下一层存在的结点推入
        root->next[i]->fail = root;
        que.push(root->next[i]);
    }

    while (!que.empty()) {
        Node *p = que.front();
        que.pop();
        for (int i = 0; i < BASE; ++i) {
            Node *k = p->fail;

            if (p->next[i] == NULL) {
                p->next[i] = k->next[i];
                continue; 
            }

            k = k->next[i];
            p->next[i]->fail = k;
            que.push(p->next[i]); 
        }
    }


    return ;
}

void match(Node *root, const char *text) {
    Node *p = root, *q;
    for (int i = 0; text[i]; ++i) {
        int ind = text[i] - 'a';

        p = p->next[ind];

        q = p;
        while (q) {
            if (q->flag == 1) printf("find : %s\n", q->str);
            q = q->fail;
        }
    }

    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; ++i) {
        if (root->tag[i]) clear(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    int n;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; ++i) {
        scanf("%s", str);
        insert(root, str);
    }
    build_ac(root);
    scanf("%s", str);
    match(root, str); // 输出字典树中所有可匹配的模式串
    clear(root);
    return 0;
}
```

### DAT 双数组字典树

字典树的普通实现浪费了大量存储边关系的空间，利用结构体数组，查找边关系改成用计算的方式得出。DAT 建立一次后，不能再修改，但是空间压缩率高，也方便输出结果到文件。

利用结构体数组静态存储字典树结点，结构体需要有 $base$ 值和 $check$ 值，$base$ 值代表本结点的子结点在数组中的起始下标地址值，其子结点的下标值就为 $base + i$, $i$ 从 0 到 25。$check$ 值是指向父结点的下标地址值，例如 $base$ 值为 6 的第 5 个子结点和 $base$ 值为 10 的第 1 个子结点地址值会计算相同，而该地址下标的结点的 $check$ 只会保留先建立它的父结点的值。

#### 代码实现

输入 $n$ 个字符，然后按字典序输出。（开启 DEBUG 查看压缩率）

```cpp
#include <bits/stdc++.h>

using namespace std;

#define BASE 26
#define DEBUG

typedef struct Node {
    int flag; 
    struct Node *next[BASE];
    const char *str;
} Node;

typedef struct DANode {
    int base; // 子结点下标的起始值
    int check; // 表示父结点在数组中的地址，另外可以用正负，额外节省标记 flag 为终止字符
    int fail; // 失败指针
    const char *str;
} DANode;

Node *getNewNode() {
    Node *p = (Node *) malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

// 返回新创建结点的数量
int insert(Node *p, const char *str) {
    int cnt = 0;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - 'a';
        if (p->next[ind] == NULL) {
            cnt += 1;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    p->str = strdup(str);
    return cnt;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

// 获取可使用的 base 值，暴力获取法，为已使用的最大下标值 + 1
int get_base(Node *root, DANode *tree) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            // 建立过程中 check 值不为 0 说明已被使用
            // 若 base 的地址值为 x ，第一个孩子结点地址值为 x + 1
            if (tree[base + i].check) flag = 0;
        }
    } while (flag == 0);
    return base;
}

// 将 Trie 树转化为 DAT 树，返回转化 DAT 数组的最大下标值
int transform_DAT(Node *root, DANode *tree, int ind) {
    if (root == NULL) return 0;
    // 如果为终止字符串，利用 check 标记
    if (root->flag) {
        tree[ind].check = -tree[ind].check;
        tree[ind].str = root->str;
    }
    
    int base = get_base(root, tree);
    tree[ind].base = base;

    // 标记子结点 check 值
    for (int i = 0; i < BASE; ++i) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;
    }
    
    // 对子结点进行递归操作建树操作
    int max_ind = ind;
    for (int i = 0; i < BASE; ++i) {
        int a = transform_DAT(root->next[i], tree, base + i);
        if (a > max_ind) max_ind = a;
    }
    return max_ind;
}

// DAT 建立失败指针，同 trie 树 ac 自动机建立过程相似
// 由于没有 next[i] 边关系了，不可以进行路径压缩
void build_ac(DANode *tree) {
    queue<int> que;
    tree[1].fail = 0;

    que.push(1);
    while (!que.empty()) {
        int p = que.front();
        que.pop();
        for (int i = 0; i < BASE; ++i) {
            int c = tree[p].base + i; // p->next[i]
            int k = tree[p].fail;
            if (abs(tree[c].check) != p) continue; // 不匹配说明子节点不存在
            
            // tree[k].base + i 类似 next[i]
            while (k && abs(tree[tree[k].base + i].check) != k) {
                k = tree[k].fail;
            }
            if (k == 0) k = 1;
            else if (abs(tree[tree[k].base + i].check) == k) k = tree[k].base + i;
            
            // next[i] fail 失败指针指向
            tree[c].fail = k;
            que.push(c);
        }
    }
    return ;
}

void match(DANode *tree, const char *text) {
    int p = 1, q;
    for (int i = 0; text[i]; ++i) {
        int ind = text[i] - 'a';
        while (p && abs(tree[tree[p].base + ind].check) != p) p = tree[p].fail;
        if (p == 0) p = 1;
        if (abs(tree[tree[p].base + ind].check) == p) p = tree[p].base + ind;

        q = p;
        while (q) {
            if (tree[q].check < 0) {
                printf("find : %s\n", tree[q].str);
            }
            q = tree[q].fail;
        }
    }
}

int main() {
    int n, cnt = 1;
    char str[1000];
    scanf("%d", &n);
    Node *root = getNewNode();
    // 计算 Trie 树总共结点值的数量
    for (int i = 0; i < n; ++i) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    // 转化为 DAT
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *) malloc(tree_size);
    memset(tree, 0, sizeof(tree_size)); // 值全置为 0
    int max_ind = transform_DAT(root, tree, 1);

    // 打印输出，对比占用空间
#ifdef DEBUG
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    printf("trie(%zu Byte), dat(%zu Byte)\n", s1, s2);
    printf("compress rate : %.2f\n", 1.0 * s2 / s1);
#endif

    build_ac(tree);
    scanf("%s", str);
    match(tree, str);
    free(tree);
    clear(root);
    
    return 0;
}
```

