---
title: 红黑树
date: 2021-03-03 19:25:41
tag: [OJ, haizeiOJ, 二叉树]
mathjax: true
---

# 红黑树

前置知识：了解二叉排序树、AVL 树的原理及代码实现。

## 性质

1. 结点是红色或者黑色
2. 根结点是红色
3. 所有叶子结点（NIL）是黑色
4. 红色结点的两个子结点都是黑色
5. 从根结点到叶子结点的路径上，黑色数目相同

红黑树从根结点到叶子结点的最长路径是最短路径的 2 倍，比 AVL 树高控制条件更松散。

## 插入调整

把每一种情况，想象成一棵大的红黑树中的局部子树，局部调整的时候，为了不影响全局，调整前后的路径上黑色数量相同，所以新插入的节点一定是红色。若直接插入到黑色结点后面，之后不需要进行调整。

插入过程要站在祖父结点去理解，主要是为了查看叔结点，逐渐向上来调整更大的局部树的 **回溯调整过程** 中，消除红色结点相连情况（此时父节点为红色，祖父结点一定为黑色）：

### 情况1

回溯调整过程中，出现父节点和被调整结点都为红色的情况，叔结点为红色结点。

通过叔结点还有父节点红颜色上浮，祖父结点颜色变为红色修改。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210302155608373.png)

### 情况2

对于被调整的结点 x 来说，叔结点是黑色，若先进行颜色调整肯定存在 **黑色结点数量失衡的情况，所以先用 AVL 的调整策略来进行左旋、右旋等操作后，再进行颜色上浮或者父结点颜色下沉调整操作。 

![失衡调整](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210302161218195.png)

![颜色调整](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210302162209829.png)

## 删除调整

被删除结点有以下情况：

1. 若无子结点时（非 NIL 结点），被删除结点为红色，直接删除，不会影响红黑树；被删除结点为黑色，删除后该节点视为 NIL 结点，并使其变成 双重黑 结点，在后续调整中减少这重黑色
2. 若有 1 个子结点时，度为 1 的结点一定为黑色结点，其子结点为红色，用子结点代替被删除结点，颜色改成黑色
3. 若有 2 个子结点时，跟二叉排序树一样，用后继结点替代被删除的结点后，视为后继结点被删除，再根据情况 1、2 来进行调整。

对于 双重黑结点 向上 **回溯调整** 的过程中，又有以下几种情况再进行调整，消除双重黑情况；调整时要进行旋转处理或变色处理，使得新根结点与原根节点相比，路径上 **黑色结点数目不变**。

### 情况1

被调整结点的兄弟结点为黑色，兄弟结点的两个子结点也为黑色。兄弟结点颜色和被调整结点的颜色都减去一重黑色（黑色变成红色，双重黑变成黑色），父节点加上一重黑色（红色变成黑色，黑色变成双重黑），若双重黑还存在，继续向上调整。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210302172126840.png)

### 情况2

兄弟结点为黑色，兄弟节点有红色子节点，位置类似 AVL 树的 RL 关系和 LR 关系，先对兄弟节点进行小右旋或小左旋处理，然后原兄弟节点的颜色变黑，新兄弟节点的颜色变红，转到 情况3 处理。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210303152431326.png)

### 情况3

兄弟结点为黑色，兄弟结点有红色子结点，位置类似 AVL 树的 RR 关系和 LL 关系，先进行大左旋或者右旋，然后新根结点变成原根节点的颜色，其下的两个子结点变成黑色，被调整结点双重黑被消去。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210303153927166.png)

### 情况4

兄弟结点为红色，此时根节点一定为黑色。通过旋转，原根结点变红，原兄弟结点变成新的根节点，颜色变黑，转变成兄弟节点是黑色的情况1、2、3来处理。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210303160113942.png)

## 代码实现

使用例题来说明：[海贼红黑树](http://oj.haizeix.com/problem/64)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210303195650564.png)

**样例输入**

```
1 1
1 2
1 3
3 0
2 2
3 0
```

**样例输出**

```
1 1 0 0
2 1 1 3
3 1 0 0
1 1 0 3
3 0 0 0
```

需要注意 NIL 的使用、颜色判断和颜色结果变化。

```cpp
#include <bits/stdc++.h>

// 用于可视化输出
// 红黑树 review 作者 xiaocui：1198016164@qq.com
#include <sys/types.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <termios.h>

using namespace std;

#define RED 0
#define BLACK 1
#define DBLACK 2

// #define DEBUG   // 启用 DEBUG 模式检查
#define COLOR_HL(a, b)      "\033[1;" #b "m" a "\033[0m"
#define GREEN_HL(a)         COLOR_HL(a, 32)
#define RED_HL(a)           COLOR_HL(a, 31)
#define BLUE_HL(a)          COLOR_HL(a, 34)
#define YELLOW_HL(a)        COLOR_HL(a, 33)
#define PURPLE_HL(a)        COLOR_HL(a, 35)
#define BOTTLEGREEN_HL(a)   COLOR_HL(a, 36)
#define MOVETO(x,y)         printf("\033[%d;%dH", (x), (y)) // 定位光标
#define CLEAR()             printf("\033[2J") // 清除屏幕

typedef struct Node {
    int key;
    int color; // 0 red 1 black 2 double black
    int h;      // DEBUG时：添加一个高度用来计算显示的距离
    struct Node *lchild, *rchild;
} Node;

// 叶子结点 NIL
Node __NIL;
#define NIL (&__NIL)
// 初始化叶子结点
__attribute__((constructor)) 
void init_NIL() {
    NIL->key = 0;
    NIL->color = BLACK;
    NIL->lchild = NIL->rchild = NIL;
    NIL->h = 0;
    return ;
}

void update_height(Node *root) {
    root->h = ((root->lchild->h > root->rchild->h) ? (root->lchild->h) : (root->rchild->h)) + 1;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *) malloc(sizeof(Node));
    p->key = key;
    // 新结点插入一定为红色
    p->color = RED;
    p->lchild = p->rchild = NIL;
    p->h = 1;
    return p;
}

int has_red_child(Node *root) {
    return root->lchild->color == RED || root->rchild->color == RED;
}

// 左旋
Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;

    update_height(root);
    update_height(temp);

    return temp;
}

// 右旋
Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;

    update_height(root);
    update_height(temp);

    return temp;
}

// 插入调整
Node *insert_maintain(Node *root) {
    if (!has_red_child(root)) return root;
    int flag = 0;
    // 情况1
    if (root->lchild->color == RED && root->rchild->color == RED) {
        // 出现双红情况调整
        if (has_red_child(root->lchild) || has_red_child(root->rchild)) {
            goto insert_end;
        }
        return root;
    }
    // 情况2
    // 被调整结点在左边
    if (root->lchild->color == RED && has_red_child(root->lchild)) {
        if (root->lchild->rchild->color == RED) {
            // LR 情况
            root->lchild = left_rotate(root->lchild); 
        }
        // LL 情况
        root = right_rotate(root);
    } 
    // 被调整结点在右边
    else if (root->rchild->color == RED && has_red_child(root->rchild)) {
        if (root->rchild->lchild->color == RED) {
            // RL 情况
            root->rchild = right_rotate(root->rchild);
        }
        // RR 情况
        root = left_rotate(root);
    } else {
        return root;
    }
    // 上浮策略
insert_end:
    root->color = RED;
    root->lchild->color = root->rchild->color = BLACK;
    // 若还存在双红情况向上传递
    return root;
}

Node *__insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) {
        root->lchild = __insert(root->lchild, key);
    } else {
        root->rchild = __insert(root->rchild, key);
    }
    // 插入完后调整
    root = insert_maintain(root);
    update_height(root);
    return root;
}

// 调整后根结点默认为黑色
Node *insert(Node *root, int key) {
    root = __insert(root, key);
    root->color = BLACK;
    return root;
}

// 获得前驱结点
Node *precessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase_maintain(Node *root) {
    // 不存在双重黑结点，不需要调整
    if (root->lchild->color != DBLACK && root->rchild->color != DBLACK) return root;
    // 情况4
    if (has_red_child(root)) {
        int flag = 0;
        // 原根节点变红
        root->color = RED;
        // LL 情况
        if (root->lchild->color == RED) {
            root = right_rotate(root);
            flag = 1;
        } else {
            // RR 情况
            root = left_rotate(root);
            flag = 2;
        }
        // 原红色兄弟结点称为新根结点，变黑色
        root->color = BLACK;
        // 到原根结点去调整，转为情况1、2、3
        if (flag == 1) {
            root->rchild = erase_maintain(root->rchild);
        } else {
            root->lchild = erase_maintain(root->lchild);
        }
        // 若还存在双重黑向上传递
        return root;
    }
    // 情况1
    if ((root->lchild->color == DBLACK && !has_red_child(root->rchild)) || 
        (root->rchild->color == DBLACK && !has_red_child(root->lchild))) {
        root->lchild->color -= BLACK;
        root->rchild->color -= BLACK;
        root->color += BLACK;
        return root;
    }
    if (root->lchild->color == DBLACK) {
        // 编码问题：由于可能再指向的是 NIL 结点
        // 此处代码效果逻辑上等同于 RL 情况
        
        // 到情况3 时肯定会先减去一重黑色
        root->lchild->color -= BLACK;
        if (root->rchild->rchild->color != RED) {
            // 情况2 RL 情况
            // 变色过程和旋转
            root->rchild->color = RED;
            root->rchild = right_rotate(root->rchild);
            root->rchild->color = BLACK;
        }
        // 情况3 RR 情况
        root = left_rotate(root);
        // 新根结点的颜色变成原根结点的颜色
        root->color = root->lchild->color;
    } else {
        root->rchild->color -= BLACK;
        if (root->lchild->lchild->color != RED) {
            root->lchild->color = RED;
            root->lchild = left_rotate(root->lchild);
            root->lchild->color = BLACK;
        }
        root = right_rotate(root);
        root->color = root->rchild->color;
    }
    // 情况3 新根结点的两个子节点变成黑色，双重黑被消除
    root->lchild->color = root->rchild->color = BLACK;
    return root;
}

Node *__erase(Node *root, int key) {
    if (root == NIL) return NIL;
    if (key < root->key) {
        root->lchild = __erase(root->lchild, key);
    } else if (key > root->key) {
        root->rchild = __erase(root->rchild, key);
    } else if (root->lchild == NIL || root->rchild == NIL) {
        // 如果没有子结点为红色不影响
        // 如果没有子结点黑色，删除后 NIL 结点本身被视为双重黑结点也可再回溯调整
        // 如果有 1 个子结点，该结点一定为黑色，子结点为红色，该结点用子结点替代，颜色变成黑色
        // 实际以上逻辑可以共享此处代码
        Node *temp = root->lchild != NIL ? root->lchild : root->rchild;
        temp->color += root->color;
        free(root);
        return temp;
    } else {
        // 如果有两个子结点，视为删掉前驱结点后，再调整
        Node *temp = precessor(root);
        root->key = temp->key;
        root->lchild = __erase(root->lchild, temp->key);
    }

    // 回溯调整
    root = erase_maintain(root);
    update_height(root);
    return root;
}

// 调整后根结点默认为黑色
Node *erase(Node *root, int key) {
    root = __erase(root, key);
    root->color = BLACK;
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

// 打印红黑树结构
void print(Node *root) {
    printf("%d %d %d %d\n", 
          root->key, root->color,
          root->lchild->key, 
          root->rchild->key
    );
    return;
}

#ifndef DEBUG
void output(Node *root) {
    if (root == NIL) return ;
    output(root->lchild);
    print(root);
    output(root->rchild);
    return ;
}
#else
struct winsize size;
__attribute__((constructor)) 
void init_WINSIZE() {
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &size);
    return ;
}

void my_print(int flag, int bit, int dis, int x, int y, Node *root) {
    MOVETO(y, x);
    if (root->color == BLACK) {
        printf("%d\n", root->key);
    } else {
        printf(RED_HL("%-*d\n"), bit / 2, root->key);
    }
    if (flag == 1) {
        for (int i = 1; i <= dis; i++) {
            MOVETO(y - i, x + i * 2 - 1);
            printf("/\n");
        }
    } else if (flag == 2) {
        for (int i = 1; i <= dis; i++) {
            MOVETO(y - i, x - i * 2 + 1);
            printf("\\\n");
        }
    }
    return ;
}

void my_output(int flag, int bit, int dis, int x, int y, Node *root) {
    if (root == NIL) return ;
    my_print(flag, bit, dis, x, y, root);
    my_output(1, bit, dis / 2, x - dis - bit, y + dis / 2 + 1, root->lchild);
    my_output(2, bit, dis / 2, x + dis + bit, y + dis / 2 + 1, root->rchild);
    return ;
}

int getMaxwidth(Node *root) {
    if (root == NIL) return 0;
    while (root->rchild != NIL) root = root->rchild;
    int maxvalue = root->key;
    int bit = 0;
    while (maxvalue) {
        bit++;
        maxvalue /= 10;
    }
    return bit;
}

void output(Node *root) {
    CLEAR();
    int bit = getMaxwidth(root);
    my_output(0, bit, pow(2, root->h - 1), size.ws_col / 2, 1, root);
}
#endif

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1:
                root = insert(root, val);
                break;
            case 2:
                root = erase(root, val);
                break;
            case 3:
                output(root);
                break;
        }
    }
    clear(root);
    return 0;
}
```

