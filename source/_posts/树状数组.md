---
title: 树状数组
date: 2021-03-09 17:25:41
mathjax: true
tag: [OJ, haizeiOJ, 树状数组]
---

# 树状数组

$lowbit(x) = (x \& -x)$，用来求数字二进制表示中最低 1 的位权（表示的单位），即为能整除 $x$ 的最大 2 的幂次



假设需要对一个整数数组求区间整数和，单次查询时间复杂度为 $O(n)$。若使用前缀和数组保存该整数数组，单次修改的时间复杂度为 $O(n)$。使用树状数组 $C$，$C[i]$ 存放的是原数组 $A$ 前 $lowbit(i)$ 个元素之和。可以用 $query(x)$ 利用 $C$ 返回前 $x$ 个整数之和，区间值为 $query$ 求差值。可以用 $update(x, v)$ 单点更新 $x$ 的值，$A[x]$ 的值修改必须覆盖包含 $A[x]$ 值的 $C$ 数组，向上传递。这样的求和以及单点更新的时间复杂度都能均摊到 $O(\log{n})$。

![树状数组理解](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309154649960.png)

![query 求和](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309154741403.png)

![update 单点更新](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309154836572.png)

树状数组还有一个经典的应用，即统计序列左边比它小的数的个数：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 10000
#define lowbit(x) (x & -x)

int c[MAX_N + 5];

void add(int i, int x, int n) {
    while (i <= n) {
        c[i] += x;
        i += lowbit(i);
    }
    return ;
}

int query(int i) {
    int sum = 0;
    while (i) {
        sum += c[i];
        i -= lowbit(i);
    }
    return sum;
}

int main() {
    int n, x;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &x);
        add(x, 1, n);
        printf("%d\n", query(x - 1)); // 查询当前小于 x 的个数
    }
    return 0;
}
```

