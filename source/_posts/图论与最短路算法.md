---
title: 图论与最短路算法
date: 2021-02-26 18:55:23
tags: [OJ, haizeiOJ, 图论, 最短路算法]
mathjax: true
---

# 图论

一般有以下三种存储方式存储图：

## 邻接矩阵

使用二维数组存储三元组，非 0 代表存在边权。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 100

int n, m, arr[MAX_N + 5][MAX_N + 5];

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int s, e, v;
        cin >> s >> e >> v;
        arr[s][e] = min(v, arr[s][e]);
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

## 邻接表

邻接矩阵在点过多时，空间可能会不够，使用邻接表动态存储每个起点到终点的关系。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m;

int main() {
    cin >> n >> m;
    // 存的还是三元组，起点，终点，边权
    vector<vector<pair<int, int> > > edg(n + 1, vector<pair<int, int> > > {});
    for (int i = 0; i < m; ++i) {
        int s, e, v;
        cin >> s >> e >> v;
        edg[s].push_back(make_pair(e, v));
    }
    for (int i = 1; i <= n; ++i) {
        cout << i << " : ";
        for (int j = 0; j < edg[i].size(); ++j) {
            cout << "{" << edg[i][j].first << ", " << edg[i][j].second << "} ";
        }
        cout << endl;
    }
}
```

## 链式前向星

链式前向星其实就是静态建立的邻接表，存储每个起点的初始边，利用结构体找下一条起点相同的边。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 100000

// 终点，边权，起点相同的下一条边的下标
struct edge {
    int e, v, next;
};

edge edg[MAX_N + 5];
// 每个起点的第一条出发边的下标
int n, m, edg_cnt, head[MAX_N + 5];

void add_edg(int a, int b, int c) {
    edg[edg_cnt].e = b;
    edg[edg_cnt].v = c;
    edg[edg_cnt].next = head[a];
    head[a] = edg_cnt++;
}

int main() {
    memset(head, -1, sizeof(head));
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int s, e, v;
        cin >> s >> e >> v;
        add_edg(s, e, v);
    }

    for (int i = 1; i <= n; ++i) {
        cout << i << " : ";
        for (int j = head[i]; j != -1; j = edg[j].next) {
            cout << "{" << edg[j].e << ", " << edg[j].v << "} ";
        }
        cout << endl;
    }
    
    return 0;
}
```

# 最短路算法

使用该例题说明：[最短路](http://oj.haizeix.com/problem/746)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210225185917091.png)

**样例输入**

```
6 6 1
1 2 3
3 5 1
2 4 6
4 1 1
2 3 9
2 3 1
```

**样例输出**

```
0
3
4
1
5
-1
```

## Floyd 算法

Floyd 算法是多源最短路算法，每个点视作路径中间可经过的点，再对每对点的最短路进行更新，更新过程为 $arr[i][j] = \min\limits_{1\le k \le j}\{arr[i][j], arr[i][k] + arr[k][j]\}$。Floyd 算法也是一种典型的动态规划算法。时间复杂度为 $O(n^3)$，$n$ 为点的数量。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAX_N 1000
#define INF 0x3f3f3f3f

// 使用邻接矩阵
int n, m, s, arr[MAX_N + 5][MAX_N + 5];

int main() {
    memset(arr, 0x3f, sizeof(arr));
    cin >> n >> m >> s;
    
    for (int i = 1; i <= n; ++i) {
        arr[i][i] = 0;
    }
    
    // 无向图
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        arr[a][b] = min(arr[a][b], c);
        arr[b][a] = min(arr[b][a], c);
    }
    
    for (int k = 1; k <= n; ++k) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]);
            }
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        if (arr[s][i] != INF) {
            cout << arr[s][i] << endl;
        } else {
            cout << -1 << endl;
        }
    }

    return 0;
}
```

## Djikstra 算法

Djikstra 算法是单源最短路径算法：每次找到一个距离起点最近的未访问点，并根据该点更新起点到其他点的距离，然后标记该点访问过，并认为到该点的最短距离确定，可认为这是一种贪心算法，或是启发式搜索（利用问题拥有的启发信息来引导搜索）。该算法不允许边上存在负权。时间复杂度为 $O(n^2)$ ，$n$ 为点的数量。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 1000
#define INF 0x3f3f3f3f

// 使用邻接矩阵
int n, m, s, arr[MAX_N + 5][MAX_N + 5];
int vis[MAX_N + 5], d[MAX_N + 5];

int main() {
    memset(arr, 0x3f, sizeof(arr));
    cin >> n >> m >> s;
    
    for (int i = 1; i <= n; ++i) {
        arr[i][i] = 0;
    }
    
    // 无向图
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        arr[a][b] = min(arr[a][b], c);
        arr[b][a] = min(arr[b][a], c);
    }
    
    memset(d, 0x3f, sizeof(d));
    d[s] = 0; // 初始化距离关系
    for (int i = 1; i <= n; ++i) {
        int k = -1, mmin = INF;
		// 找到未访问过的点中距离最近的，第一次会选择起始点
        for (int j = 1; j <= n; ++j) {
            if (!vis[j] && d[j] < mmin) {
                k = j;
                mmin = d[i];
            }
        }

        if (k == -1) break; // 找不到可连通点
        vis[k] = 1; // 标记已访问
        for (int j = 1; j <= n; ++j) {
            // 更新最短距离
            if (!vis[j] && arr[k][j] != INF && d[k] + arr[k][j] < d[j]) {
                d[j] = d[k] + arr[k][j];
            }
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        if (d[i] != INF) {
            cout << d[i] << endl;
        } else {
            cout << -1 << endl;
        }
    }

    return 0;
}

```

## Djikstra 基于堆的优化算法

Dijkstra 算法还可以有另一种写法，利用最小堆的性质，每次从堆中取出的最小值就是下一次要用的顶点，后面的搜索只要距离超过这个距离则此分支不用继续搜索了。时间复杂度为 $O(m * \log{n})$，$m$ 为边的数量，$n$ 为点的数量。

```cpp

#include <bits/stdc++.h>
using namespace std;

# define MAX_N 100000
# define INF 0x3f3f3f3f

// 链式前向星解决最短路 dijkstra 问题
struct node {
    int now, val;
    // 使其称为最小堆
    bool operator< (const node &b) const {
        return this->val > b.val;
    }
};

struct edge {
    int e, v, next;
};

edge edg[2 * MAX_N + 5];
int n, m, s, edg_cnt, head[MAX_N + 5], ans[MAX_N + 5];

void add_edge(int a, int b, int c) {
    edg[edg_cnt].e = b;
    edg[edg_cnt].v = c;
    edg[edg_cnt].next = head[a];
    head[a] = edg_cnt++;
}

int main() {
    memset(head, -1, sizeof(head));
    memset(ans, 0x3f, sizeof(ans));
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add_edge(a, b, c);
        add_edge(b, a, c);
    }

    priority_queue<node> que;
    que.push((node) {s, 0});
    ans[s] = 0;
    while (!que.empty()) {
        node temp = que.top();
        que.pop();

        // 最优值已经被更新，跳过陈旧值
        if (temp.val > ans[temp.now]) {
            continue;
        }

        // 看该起点是否还可以继续找到下一条边
        for (int i = head[temp.now]; i != -1; i = edg[i].next) {
            int e = edg[i].e, v = edg[i].v;
            if (ans[e] > temp.val + v) {
                ans[e] = temp.val + v;
                que.push((node) {e, ans[e]});
            }
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (ans[i] != INF) {
            printf("%d\n", ans[i]);
        } else {
            printf("-1\n");
        }
    }

    return 0;
}
```

## Bellman-ford 算法

Bellman-ford 算法是一种单源最短路算法，从所有点开始，暴力遍历所有边，根据这条边的起点的答案，再加上边的权值，去更新边的终点的答案。该算法允许边上负权存在，但是不允许负环（一个点出发后回到原点，路径反而更短）存在。时间复杂度为 $O(n \times m)$，$n$ 为点的数量，$m$ 为边的数量。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 100000
#define INF 0x3f3f3f3f

struct edge {
    int s, e, v;
};

// Bellman-ford 算法只用考虑边集，和点到目标的答案
int n, m, s, edg_cnt, ans[MAX_N + 5];
edge edg[2 * MAX_N + 5];

void add_edg(int a, int b, int c) {
    edg[edg_cnt].s = a;
    edg[edg_cnt].e = b;
    edg[edg_cnt].v = c;
    edg_cnt++;
}

int main() {
    
	memset(ans, 0x3f, sizeof(ans));
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add_edg(a, b, c);
        add_edg(a, c, b);
    }
    ans[s] = 0;
    for (int i = 1; i <= n; ++i) {
        int f = 0;
        for (int j = 0; j < edg_cnt; ++j) {
            if (ans[edg[j].e] > ans[edg[j].s] + edg[j].v) {
                ans[edg[j].e] = ans[edg[j].s] + edg[j].v;
                f = 1;
            }
        }
        // 没有边被更新，提前结束
        if (f == 0) break;
    }
    for (int i = 1; i <= n; ++i) {
        if (ans[i] != INF) {
            printf("%d\n", ans[i]);
        } else {
            printf("-1\n");
        }
    }
    
    return 0;
}
```

## 基于队列优化的 Bellman-ford 算法

又称 SPFA 算法，分析 Bellman-ford 算法，找到连通关系，避免不必要的遍历。可以使用队列，减少这种现象。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 100000
#define INF 0x3f3f3f3f

// 基于链式前向星存储结构解答
struct edge {
    int e, v, next;
};

edge edg[2 * MAX_N + 5];
int n, m, s, edg_cnt, ans[MAX_N + 5], head[MAX_N + 5], mark[MAX_N + 5];

void add_edg(int a, int b, int c) {
    edg[edg_cnt].e = b;
    edg[edg_cnt].v = c;
    edg[edg_cnt].next = head[a];
    head[a] = edg_cnt++;
}

int main() {
    memset(ans, 0x3f, sizeof(ans));
    memset(head, -1, sizeof(head));
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add_edg(a, b, c);
        add_edg(b, a, c);
    }
    ans[s] = 0;
    
    queue<int> que;
    que.push(s);
    while (!que.empty()) {
        int temp = que.front();
        que.pop();
        mark[temp] = 0; 
        // 需要检查所有出发点所有邻边，所以不能用原有 Bellman-ford 算法所用数据结构
        for (int i = head[temp]; i != -1; i = edg[i].next) {
            int e = edg[i].e, v = edg[i].v;
            if (ans[e] > ans[temp] + v) {
                ans[e] = ans[temp] + v;
                // 对其进行标记，减少重复推入
                if (mark[e] == 0) {
                    que.push(e);
                    mark[e] = 1;
                }
            }
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        if (ans[i] != INF) {
            printf("%d\n", ans[i]);
        } else {
            printf("-1\n");
        }
    }
    
    return 0;
}
```

