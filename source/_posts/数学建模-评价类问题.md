---
title: 数学建模-评价类问题
date: 2021-05-14 20:01:05
mathjax: true
tag: [数学建模]
---



# 评价类问题

例如：选择那种方案更好，哪个员工或者运动员更优秀。

评价类问题用打分解决，使用权重对各个对象进行各方面综合打分，各方面的占比为权重，其和为 1。

确定评价体系、形成评价指标：

- 评价的目标是什么（例选择最佳的 xxx）
- 可选方案有哪些 （题目中给出的各个对象）
- 评价准则或指标是什么 （根据什么来评价好坏）

如果题目没有数据支撑来确定评价准则，需要自己根据背景资料、常识及网上的资料来确定。



**直接** 进行权重表格来进行填表会怎么样？

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420141905625.png)

会导致考虑不周全、重要性程度不相一致，提出一组隐含矛盾的数据。

## 层次分析法

先考虑指标与指标之间的关系，进行 **两两比较**。

然后再计算该指标下各个对象进行 **两两比较**，得出相应的权重得分。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420142508201.png)

如果评价传递之间，出现了矛盾之处：A>B，B>C, C>A，需要将矩阵调整为 **一致矩阵**。

$a_{ik} = a_{ij} \times a_{jk}$，矩阵 各行（各列） 之间成倍数关系。

所以使用判断矩阵求权重之前，必须先进行一致性检验（与一致矩阵是否有太大的差别）。

```matlab
A = [
	1 2 4;
	1/2 1 2;
	1/4 1/2 1
]
[V, D] = eig(A) % 求出特征向量和特征值
A * [1; 1/2; 1/4] - 3 * [1; 1/2; 1/4] % 验证特征值对应的特征向量
```

一致矩阵 只有一个特征值为 $n$ 其余为 0，当 正互反矩阵 非一致时，最大特征值 $\lambda_{max} \gt n$。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420145055408.png)

```matlab
a = [1:1:8]
for i = 1:size(a, 2)
	A = [
		1 2 a(i);
		1/2 1 2;
		1/a(i) 1/2 1
	]
	b = [b max(eig(A))]
end
plot(a, b)
```

### 一致性检验步骤

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420145549930.png)

### 使用判断矩阵计算权重

#### 算数平均法

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420150136897.png)

#### 几何平均法

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420150242875.png)

#### 特征值法

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420150546640.png)



### 步骤整合

再根据各指标计算的权重结果和指标间的比较计算结果，填入权重表中去。（三种方法都试）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420152052224.png)

计算可使用 Excel 进行计算（按 F4 锁定计算单元格）

计算步骤重述：

第一步：（使用 Visio 等画图）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogblogimage-20210420152430628.png)

第二步：写出判断矩阵

第三步：进行一致性检验，计算相对权重

第四步：计算得分，排序

```matlab
disp('输入判断矩阵')
A = input('判断矩阵 A = ');

% 算数平均法
Sum_A = sum(A); % 按列求和，先归一化
n = size(A, 1);
SUM_A = repmat(Sum_A, n, 1);
Stand_A = A ./ SUM_A;
disp('算数平均法求权重的结果为：')
disp(sum(Stand_A, 2) / n)

% 几何平均法
Product_A = prod(A, 2); % 按行相乘
Product_n_A = Product_A .^ (1 / n); % 开 n 次方
disp('几何平均法求权重的结果为：')
disp(Product_n_A ./ sum(Product_n_A)) % 再归一化

% 特征值法
[V, D] = eig(A); % 特征向量和特征值 D 是特征值对角矩阵
Max_eig = max(max(D));
[r, c] = find(D == Max_eig, 1); % find 返回矩阵中前 n 各不为 0 的下标索引
disp('特征值法求权重的结果为：') 
disp(V(:, c) ./ sum(V(:, c))) % 对应列特征向量归一化

% 一致性比例计算
CI = (Max_eig - n) / (n - 1);
RI = [0 0 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59];
CR = CI / RI(n)

if CR < 0.10
    disp('因为CR < 0.10，所以该判断矩阵A的一致性可以接受!')
else
    disp('注意：CR >= 0.10，因此该判断矩阵A需要进行修改!')
end
```

### 局限性

1. 决策层（指标） $n$ 不能太多
2. 主观确定决策层数据，如果决策层指标数据已知，可以使用其他更精确的方法



## 优劣解距离法

又称为 Topsis 法。

其利用原始数据的信息，客观反应各评价方案之间的差距。

归一化构造计算评分：

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420161550792.png)

存在极大型指标（效益性）和极小型指标（成本型），需要将所有指标都转化成极大型，对极小型来说，指标正向化最常用 $max-x$

除此之外，指标与指标间存在量纲，需要进行 **标准化处理**。

Tip：

- 归一化，数据分布到 [0, 1] 区间或指定区间

- 标准化，数据变化到 均值为 0， 标准差为 1 的分布
- 中心化，所有数据减去数据的均值

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420162634874.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420162907068.png)



Topsis 法基本过程为 先将原始数据矩阵统一指标类型（一般正向化处理）得到正向化的矩阵，再对正向化的矩阵进行标准化处理以消除各指标量纲的影响，并找到有限方案中的最优方案和最劣方案，然后分别计算各评价对象与最优方案和最劣方案间的距离，获得各评价对象与最优方案的相对接近程度，以此作为评价优劣的依据。该方法对数据分布及样本含量没有严格限制，数据计算简单易行。



### 指标正向化

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420163134882.png)

#### 极小型指标

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420163206835.png)

#### 中间型指标

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420163303729.png)

#### 区间型指标

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420163340736.png)

### 步骤整合

第一步：将原始矩阵正向化

第二步：正向化矩阵标准化

第三步：计算归一化的得分

可以的话再到 Excel 中去，对得分做一个条状图显示及排序。

Topsis 法还可以跟层次分析法结合，对指标确定权重

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420164035178.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420164101291.png)



```matlab
% 极小型指标正向化
function [posit_x] = Min2Max(x)
    posit_x = max(x) - x;
end

% 中间型指标正向化
function [posit_x] = Mid2Max(x, best)
    M = max(abs(x - best));
    posit_x = 1 - abs(x - best) / M;
end

% 区间型指标正向化
function [posit_x] = Inter2Max(x, a, b)
	r_x = size(x, 1);
	M = max([a - min(x), max(x) - b]);
	posit_x = zeros(r_x, 1);
	for i = 1:r_x
		if x(i) < a
			posit_x(i) = 1 - (a - x(i)) / M;
		elseif x(i) > b
			posit_x(i) = 1 - (x(i) - b) / M;
		else
			posit_x(i) = 1;
		end
	end
end

function [posit_x] = Positivization(x, type, i)
% 输入：
% x：需要正向化处理的指标对应的原始列向量
% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）
% i： 说明正在处理的是原始矩阵中的哪一列
% 输出：
% posit_x：正向化后的列向量
    if type == 1  %极小型
        disp(['第' num2str(i) '列是极小型，正在正向化'] )
        posit_x = Min2Max(x);
        disp(['第' num2str(i) '列极小型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    elseif type == 2  %中间型
        disp(['第' num2str(i) '列是中间型'] )
        best = input('请输入最佳的那一个值： ');
        posit_x = Mid2Max(x, best);
        disp(['第' num2str(i) '列中间型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    elseif type == 3  %区间型
        disp(['第' num2str(i) '列是区间型'] )
        a = input('请输入区间的下界： ');
        b = input('请输入区间的上界： '); 
        posit_x = Inter2Max(x,a,b);
        disp(['第' num2str(i) '列区间型正向化处理完成'] )
        disp('~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~')
    else
        disp('没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值')
    end
end

function [lnp] =  mylog(p)
	n = length(p);
	lnp = zeros(n,1); 
    for i = 1:n
        if p(i) == 0   % 如果第i个元素为0 那么返回的第i个结果也为0
            lnp(i) = 0; 
        else
            lnp(i) = log(p(i));  
        end
    end
end

function [W] = Entropy_Method(Z)
% 计算有 n 个样本，m 个指标的样本所对应的的熵权
% 输入
% Z ： n * m 的矩阵（要经过正向化和标准化处理，且元素中不存在负数）
% 输出
% W：熵权，1 * m 的行向量
    [n, m] = size(Z);
    D = zeros(1, m);  % 初始化保存信息效用值的行向量
    for i = 1:m
        x = Z(:, i);  % 取出第i列的指标
        p = x / sum(x);
        % 注意，p有可能为0，此时计算ln(p)*p时，Matlab会返回NaN，所以这里我们自己定义一个函数
        e = -sum(p .* mylog(p)) / log(n); % 计算信息熵
        D(i) = 1 - e; % 信息效用值
    end
    W = D ./ sum(D);  % 将信息效用值归一化，得到权重    
end

load data_water_quality.mat
[n, m] = size(X);
disp(['共有' num2str(n) '个评价对象, ' num2str(m) '个评价指标']) 
Judge = input(['这' num2str(m) '个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  ']);

if Judge == 1
	% 注意，Position和Type是两个同维度的行向量
    Position = input('请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： ');
    disp('请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型）')
    Type = input('例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：');
    for i = 1:size(Position, 2) %这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数
        X(:, Position(i)) = Positivization(X(:, Position(i)), Type(i), Position(i));
    end
    disp('正向化后的矩阵 X = ')
    disp(X)
end

disp("请输入是否需要增加权重向量，需要输入1，不需要输入0")
Judge = input('请输入是否需要增加权重： ');
if Judge == 1
	Judge = input('使用熵权法确定权重请输入1，否则输入0： ');
	if Judge == 1
        if sum(sum(Z < 0)) > 0   % 如果之前标准化后的Z矩阵中存在负数，则重新对X进行标准化
            disp('原来标准化得到的Z矩阵中存在负数，所以需要对X重新标准化')
            for i = 1:n
                for j = 1:m
                    Z(i,j) = [X(i, j) - min(X(:, j))] / [max(X(:, j)) - min(X(:, j))];
                end
            end
            disp('X重新进行标准化得到的标准化矩阵Z为:  ')
            disp(Z)
        end
        weight = Entropy_Method(Z);
        disp('熵权法确定的权重为：')
        disp(weight)
    else 
        disp(['如果你有3个指标，你就需要输入3个权重，例如它们分别为0.25,0.25,0.5, 则你需要输入[0.25,0.25,0.5]']);
        weight = input(['你需要输入' num2str(m) '个权数。' '请以行向量的形式输入这' num2str(m) '个权重: ']);
        OK = 0;
        while OK == 0 
            % 这里要注意浮点数的运算是不精准的。
            if abs(sum(weight) - 1) < 0.000001 && size(weight, 1) == 1 && size(weight, 2) == m   
                OK = 1;
            else
                weight = input('输入有误，请重新输入权重行向量: ');
            end
        end
   	end
else
    weight = ones(1, m) ./ m ; % 不需要加权重就默认权重都相同，即都为1/m
end

%% 进行标准化
Z = X ./ repmat(sum(X .* X) .^ 0.5, n, 1);
disp('标准化矩阵 Z = ')
disp(Z)

%% 计算与最大值的距离和最小值的距离，并算出得分
D_P = sum([(Z - repmat(max(Z), n, 1)) .^ 2 ], 2) .* repmat(weight, n, 1) ,2) .^ 0.5; % D+
D_N = sum([(Z - repmat(min(Z), n, 1)) .^ 2 ], 2) .* repmat(weight, n, 1) ,2) .^ 0.5; % D-
S = D_N ./ (D_P + D_N); 
disp('最后的得分为：')
Stand_S = S / sum(S) % 最后再进行归一化
[sorted_S, index] = sort(Stand_S, 'descend')
```

### 熵权法

层次分析法再赋权，主观性太强，客观 = 数据本身就可以告诉我们权重。

指标的 **变异** 程度越小，所反映的信息量也越少，其对应的权值也应该越低。

用指标的标准差来衡量样本的变异程度，指标的标准差越大，其信息熵越小。

越不可能发生的事情，信息量越多；信息熵越大，信息量越小。



![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420183258315.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420183352485.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420190226782.png)

```matlab
%% 蒙特卡洛模拟：指标的标准差和信息熵成反比
n = 30;
N = 100;
result = zeros(N, 2);
for i = 1:N
	x = rand(n, 1); % 随机生成 n 个位于 (0, 1) 区间的样本
	p = x / sum(x);
	e = -sum(p .* mylog(p)) / log(n);
	sd = std(x); % 标准差
	result(i, 1) = e;
	result(i, 2) = sd;
end

plot(result(:, 1), result(:, 2), 'o')
xlabel('信息熵')
ylabel('标准差')
[r, p] = corrcoef(result(:, 1), result(:, 2)) % 计算相关系数和对应 p 值（相关性检验和假设验证）
```

#### 步骤

1）标准化（两种方法）

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420183624362.png)

2）计算 相对熵计算所要用的概率

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420183749023.png)



3）计算信息熵，计算信息效用值，由此归一化得出每个指标的熵权

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420184205788.png)

但不是 **所有情况** 都适合使用 熵权法，合适的时候使用。

## 灰色关联分析

创建虚拟母序列，视为系统行为特征。

计算灰色关联度来作为权重。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420202436009.png)

```matlab
load data_water_quality.mat

%% 判断是否需要正向化
[n, m] = size(X);
disp(['共有' num2str(n) '个评价对象, ' num2str(m) '个评价指标']) 
Judge = input(['这' num2str(m) '个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  ']);

if Judge == 1
	% 注意，Position和Type是两个同维度的行向量
    Position = input('请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： ');
    disp('请输入需要处理的这些列的指  标类型（1：极小型， 2：中间型， 3：区间型） ')
    Type = input('例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  ');
    for i = 1 : size(Position, 2)
        X(:,Position(i)) = Positivization(X(:,Position(i)), Type(i), Position(i));
    end
    disp('正向化后的矩阵 X =  ')
    disp(X)
end

%% 对正向化后的矩阵进行预处理
Mean = mean(X);
Z = X ./ repmat(Mean, size(X,1), 1); 
disp('预处理后的矩阵为：'); 
disp(Z)

%% 构造母序列和子序列
Y = max(Z,[],2);  % 母序列为虚拟的，用每一行的最大值构成的列向量表示母序列（max用法）
X = Z; % 子序列就是预处理后的数据矩阵

%% 计算得分
absX0_Xi = abs(X - repmat(Y, 1, size(X, 2)))  % 计算|X0-Xi|矩阵
a = min(min(absX0_Xi)) % 计算两级最小差a
b = max(max(absX0_Xi)) % 计算两级最大差b
rho = 0.5; % 分辨系数取0.5
gamma = (a + rho*b) ./ (absX0_Xi  + rho * b); % 计算子序列中各个指标与母序列的关联系数
weight = mean(gamma) / sum(mean(gamma)); % 利用子序列中各个指标的灰色关联度计算权重
score = sum(X .* repmat(weight, size(X,1), 1), 2); % 未归一化的得分
Stand_S = score / sum(score);  % 归一化后的得分
[sorted_S, index] = sort(Stand_S, 'descend') % 进行排序
```

## 模糊综合评价

模糊性：非确定性概念（帅，高，白，年轻）。

模糊集合承认亦此亦彼。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420211626286.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210420211659726.png)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421102121700.png)

一级模糊综合评价例题（3道，可查 pdf）：

对于综合评价，可把方案视为评语集，指标视为因素级，采用主观或客观方法得出权重。

指标必须经过正向化。

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210421111750925.png)

多级模糊综合评价例题（2道），可以简化对比计算。

模糊综合评价方法最好在题目给出隶属度相关信息的时候使用。