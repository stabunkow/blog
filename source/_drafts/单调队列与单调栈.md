---
title: 单调队列与单调栈
date: 2021-03-09 20:24:41
mathjax: true
tag: [OJ, haizeiOJ, 单调队列, 单调栈]
---

# 单调队列

单调队列常用于维护滑动窗口最值，即允许区间移动的区间最值问题 RMQ。

入队：将队尾违反单调性的元素淘汰出局，再将当前元素入队

出队：如果队首元素超出了滑动窗口的范围，队首出队

队首：滑动窗口的最值



使用该例题进行说明：

## [滑动窗口](http://oj.haizeix.com/problem/271)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309204101834.png)

**样例输入**

```
8 3
1 3 -1 -3 5 3 6 7
```

**样例输出**

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

**代码实现**

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 300000

// 队列保存的是值下标，方便判断长度关系
// 队列需要查看队尾值，不使用 std
int q[MAX_N + 5], head, tail;
int val[MAX_N + 5];

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", val + i);
    }
    for (int i = 1; i <= n; ++i) {
        // 违反单调性的队尾元素出队
        while (tail != head && val[q[tail - 1]] > val[i]) --tail;
        q[tail++] = i; // 入队
        if (q[head] <= i - k) head++; // 超出滑动窗口大小
        if (i >= k) {
            i > k && printf(" ");
            printf("%d", val[q[head]]); // 输出队首值
        }
    }
    printf("\n");
    head = tail = 0;
    for (int i = 1; i <= n; ++i) {
        while (tail != head && val[q[tail - 1]] < val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && printf(" ");
            printf("%d", val[q[head]]);
        }
    }
    printf("\n");
    
    return 0;
}
```

# 单调栈

栈顶元素为最近大于小于关系。

入栈：将栈顶违反单调性的元素淘汰出局，再将当前元素入栈。



使用该例题进行说明：

## [最大矩形面积](http://oj.haizeix.com/problem/264)

![](https://hauk-blog.oss-cn-hangzhou.aliyuncs.com/blogimage-20210309205229289.png)

**样例输入**

```
7
2 1 4 5 1 3 3
```

**样例输出**

```
8
```

对于每个矩形，需要求出其最左右两边最近的小于关系，来计算矩形最大值。若每次对每个矩形再遍历求一边左右最近小于关系，那么时间复杂度为 $O(n^2)$，$n$ 为矩形的数量。如果使用单调栈，可以把时间复杂度降到 $O(n)$。

**代码实现**

```cpp
#include <bits/stdc++.h>

using namespace std;

#define MAX_N 100000

long long h[MAX_N + 5], n;
long long s[MAX_N + 5], top; // 栈存的是下标
long long l[MAX_N + 5], r[MAX_N + 5]; // 左右最近小于当前高度的下标

void read() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; ++i) scanf("%lld", h + i);
    return ;
}

// 采用单调栈维护最近最大最小关系解决该问题
long long solve() {
    h[0] = h[n + 1] = -1; // trick 左右两端默认加两个极小值
    top = -1;
    s[++top] = 0;
    for (int i = 1; i <= n; ++i) {
        while (top != -1 && h[s[top]] >= h[i]) --top; // !#
        l[i] = s[top];
        s[++top] = i;
    }
    top = -1;
    for (int i = n; i >= 1; --i) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        r[i] = s[top];
        s[++top] = i;
    }
    long long ans = 0;
    for (int i = 1; i <= n; ++i) {
        ans = max(ans, h[i] * (r[i] - l[i] - 1));
    }
    return ans;
}

int main() {
    read();
    printf("%lld\n", solve());
    return 0;
}
```

